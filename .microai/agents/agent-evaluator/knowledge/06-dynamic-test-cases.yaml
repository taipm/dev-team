# Advanced Dynamic Test Cases v2.0
# Designed by: Deep Thinking Team (Dijkstra, Linus, Polya, Munger)
# Purpose: Differentiate LLM capabilities across complexity tiers

metadata:
  version: "2.0"
  designed_by: "Deep Thinking Team (Dijkstra, Linus, Polya, Munger)"
  total_tests: 20
  max_score: 100
  philosophy: "Quality of reasoning > Presence of keywords"

  tiers:
    - name: "Easy"
      score_range: "1-3"
      expected: "All models pass (80%+)"
    - name: "Medium"
      score_range: "3-5"
      expected: "Local models 40-60%, Cloud 70%+"
    - name: "Hard"
      score_range: "5-8"
      expected: "Local 20-40%, Cloud 50-70%"
    - name: "Expert"
      score_range: "8-12"
      expected: "Differentiates opus > sonnet > haiku"

# =============================================================================
# TIER 1: EASY (15 points total) - All models should score 80%+
# =============================================================================

easy_tier:
  total_points: 15
  tests:
    - id: "E-1"
      name: "Basic Syllogism"
      category: "Logic"
      difficulty: 1
      points: 3
      prompt: "All Go functions that return errors should be checked. The function ReadFile returns an error. What should the caller do?"
      keywords: ["check", "handle", "error", "if err", "nil"]
      rubric: |
        3 pts: States to check error with code pattern
        2 pts: States to handle error without code
        1 pt: Mentions error handling vaguely

    - id: "E-2"
      name: "Simple Dependency"
      category: "Reasoning"
      difficulty: 1
      points: 3
      prompt: "Package A imports B. Package B has no imports. What initializes first?"
      keywords: ["B", "first", "before", "dependency"]
      rubric: |
        3 pts: Correct answer with Go init explanation
        2 pts: Correct answer without explanation
        1 pt: Mentions dependency but unclear

    - id: "E-3"
      name: "Interface Implicit"
      category: "Go Knowledge"
      difficulty: 1
      points: 3
      prompt: "In Go, does a struct need to explicitly declare that it implements an interface?"
      keywords: ["no", "implicit", "duck typing", "automatically"]
      rubric: |
        3 pts: Explains implicit satisfaction
        2 pts: Correct with brief explanation
        1 pt: Correct answer only

    - id: "E-4"
      name: "Map Concurrency"
      category: "Concurrency"
      difficulty: 1
      points: 3
      prompt: "Two goroutines write to the same map without synchronization. What happens?"
      keywords: ["race", "data race", "crash", "fatal", "unsafe", "undefined"]
      rubric: |
        3 pts: Identifies race with consequences
        2 pts: Mentions race condition
        1 pt: Says it's unsafe

    - id: "E-5"
      name: "Nil vs Empty Slice"
      category: "Go Knowledge"
      difficulty: 1
      points: 3
      prompt: "What is the difference between 'var s []int' and 's := []int{}'?"
      keywords: ["nil", "empty", "allocated", "json", "marshal"]
      rubric: |
        3 pts: Explains nil vs empty with JSON difference
        2 pts: Identifies nil vs empty correctly
        1 pt: Knows different but unclear

# =============================================================================
# TIER 2: MEDIUM (25 points total) - Local 40-60%, Cloud 70%+
# =============================================================================

medium_tier:
  total_points: 25
  tests:
    - id: "M-1"
      name: "Complex Dependency Chain"
      category: "Reasoning"
      difficulty: 3
      points: 5
      prompt: |
        Service dependencies:
        - API Gateway → Auth Service → User DB
        - API Gateway → Product Service → Product DB
        - Product Service → Cache Service
        - Auth Service → Cache Service
        In what order should services start for a clean boot sequence?
      keywords: ["DB", "Cache", "Auth", "Product", "Gateway"]
      order_matters: true
      rubric: |
        5 pts: Correct order with parallel opportunities
        4 pts: Correct sequential order
        3 pts: Mostly correct with 1 error
        2 pts: Understands concept but wrong order

    - id: "M-2"
      name: "Context Cancellation Bug"
      category: "Concurrency"
      difficulty: 3
      points: 5
      prompt: |
        ```go
        func process(ctx context.Context) error {
            for i := 0; i < 1000; i++ {
                time.Sleep(10 * time.Millisecond)
            }
            return nil
        }
        ```
        What's wrong with this function's context handling?
      keywords: ["ctx.Done", "select", "cancellation", "check context", "ignore"]
      rubric: |
        5 pts: Identifies issue with corrected code
        4 pts: Identifies issue with explanation
        3 pts: Mentions context not checked
        2 pts: Vague context issues

    - id: "M-3"
      name: "Error Wrapping"
      category: "Error Handling"
      difficulty: 3
      points: 5
      prompt: |
        You have three layers: Handler → Service → Repository.
        Repository returns: errors.New("connection refused")
        How should errors be wrapped through the layers for debugging?
      keywords: ["%w", "fmt.Errorf", "errors.Wrap", "chain", "context"]
      rubric: |
        5 pts: Shows proper wrapping at each layer
        4 pts: Explains wrapping correctly
        3 pts: Uses wrapping but wrong syntax
        2 pts: Adds context but no wrapping

    - id: "M-4"
      name: "Interface Segregation"
      category: "Design"
      difficulty: 3
      points: 5
      prompt: |
        ```go
        type DataStore interface {
            Create(item Item) error
            Read(id string) (Item, error)
            Update(item Item) error
            Delete(id string) error
            List() ([]Item, error)
            Search(query string) ([]Item, error)
            Backup() error
            Restore() error
        }
        ```
        A component only needs to read items. What's the design problem?
      keywords: ["interface segregation", "too large", "Reader", "smaller", "ISP"]
      rubric: |
        5 pts: Identifies ISP with refactored interfaces
        4 pts: Explains problem with splitting suggestion
        3 pts: Identifies interface too large
        2 pts: Vague design issue mention

    - id: "M-5"
      name: "Race in Counter"
      category: "Concurrency"
      difficulty: 3
      points: 5
      prompt: |
        ```go
        type Counter struct { count int }
        func (c *Counter) Increment() { c.count++ }
        func (c *Counter) Get() int { return c.count }
        ```
        Multiple goroutines call Increment() and Get(). Is this safe?
      keywords: ["not safe", "mutex", "atomic", "sync", "race"]
      rubric: |
        5 pts: Identifies race with sync.Mutex fix
        4 pts: Identifies race with solution idea
        3 pts: Identifies unsafe
        2 pts: Vague potential issues

# =============================================================================
# TIER 3: HARD (35 points total) - Local 20-40%, Cloud 50-70%
# =============================================================================

hard_tier:
  total_points: 35
  tests:
    - id: "H-1"
      name: "Deadlock Analysis"
      category: "Concurrency"
      difficulty: 5
      points: 7
      prompt: |
        ```go
        func transfer(from, to *Account, amount int) {
            from.mu.Lock()
            defer from.mu.Unlock()
            to.mu.Lock()
            defer to.mu.Unlock()
            from.balance -= amount
            to.balance += amount
        }
        ```
        Two goroutines: transfer(A, B, 100) and transfer(B, A, 50).
        Explain the problem and provide a solution.
      keywords: ["deadlock", "lock order", "consistent", "circular", "waiting"]
      rubric: |
        7 pts: Deadlock + mechanism + solution code
        6 pts: Deadlock + correct solution concept
        5 pts: Deadlock + partial solution
        4 pts: Identifies deadlock only
        3 pts: Mentions locking issue

    - id: "H-2"
      name: "Multiple Code Bugs"
      category: "Code Review"
      difficulty: 5
      points: 7
      prompt: |
        ```go
        func processRequests(requests <-chan Request) {
            for req := range requests {
                go func() {
                    result := process(req)
                    _ = result
                }()
            }
        }
        ```
        What are ALL problems with this code?
      keywords: ["loop variable", "closure", "capture", "unbounded", "goroutine leak"]
      rubric: |
        7 pts: All issues (closure + unbounded goroutines)
        6 pts: Closure + goroutine issue
        5 pts: Two issues identified
        4 pts: Closure bug with fix
        3 pts: One issue

    - id: "H-3"
      name: "REST API Review"
      category: "Architecture"
      difficulty: 5
      points: 7
      prompt: |
        Review this REST API design:
        POST /users/create
        GET /users/getUser?id=123
        PUT /users/updateUser
        DELETE /users/deleteUser?id=123
        GET /users/getAllUsers
        List design problems and suggest improvements.
      keywords: ["redundant", "verb in URL", "RESTful", "resource", "inconsistent"]
      rubric: |
        7 pts: Comprehensive with RESTful redesign
        6 pts: 3+ issues with improvements
        5 pts: Major issues with some improvements
        4 pts: 2-3 issues identified
        3 pts: 1-2 issues

    - id: "H-4"
      name: "Fan-In Pattern"
      category: "Concurrency"
      difficulty: 6
      points: 7
      prompt: |
        Implement a fan-in function that:
        1. Merges multiple input channels into one output
        2. Handles channel closure gracefully
        3. Stops when context is cancelled
        4. Does not leak goroutines
        Provide implementation sketch.
      keywords: ["select", "WaitGroup", "ctx.Done", "close", "range"]
      rubric: |
        7 pts: Complete correct implementation
        6 pts: Working, minor issues
        5 pts: Core logic correct, missing cleanup
        4 pts: Understands pattern, incomplete
        3 pts: Partial fan-in understanding

    - id: "H-5"
      name: "SQL Injection"
      category: "Security"
      difficulty: 6
      points: 7
      prompt: |
        ```go
        func getUserData(w http.ResponseWriter, r *http.Request) {
            userID := r.URL.Query().Get("id")
            query := fmt.Sprintf("SELECT * FROM users WHERE id = '%s'", userID)
            rows, _ := db.Query(query)
        }
        ```
        Identify ALL security issues and fix them.
      keywords: ["SQL injection", "parameterized", "prepared", "error handling", "sanitize"]
      rubric: |
        7 pts: SQL injection + error handling + secure code
        6 pts: SQL injection with parameterized fix
        5 pts: SQL injection with partial fix
        4 pts: Identifies injection without proper fix
        3 pts: Vague security concern

# =============================================================================
# TIER 4: EXPERT (25 points total) - Separates opus > sonnet > haiku
# =============================================================================

expert_tier:
  total_points: 25
  tests:
    - id: "X-1"
      name: "Distributed Rate Limiter"
      category: "System Design"
      difficulty: 8
      points: 10
      prompt: |
        Design a distributed rate limiter that:
        1. Works across multiple API gateway instances
        2. Supports per-user and global rate limits
        3. Handles network partitions gracefully
        4. Has sub-millisecond latency for most requests
        Describe architecture, data structures, and trade-offs.
      keywords: ["Redis", "sliding window", "token bucket", "local cache", "consistency", "CAP"]
      reasoning_required: true
      rubric: |
        10 pts: Comprehensive design + trade-off analysis
        8-9 pts: Solid design covering most requirements
        6-7 pts: Basic distributed design with gaps
        4-5 pts: Understands problem, incomplete
        2-3 pts: Single-node solution only

    - id: "X-2"
      name: "Complex Refactoring"
      category: "Code Quality"
      difficulty: 8
      points: 8
      prompt: |
        A 200-line function processes orders with nested if-else:
        - Different order types (express, standard, international)
        - Different user types (premium, regular)
        - Multiple service calls (inventory, payment, shipping)
        Propose refactoring strategy using SOLID principles.
      keywords: ["strategy", "interface", "dependency injection", "single responsibility", "separate"]
      reasoning_required: true
      rubric: |
        8 pts: Comprehensive refactoring with patterns
        6-7 pts: Good strategy with SOLID
        4-5 pts: Basic refactoring ideas
        2-3 pts: Suggests breaking up without pattern

    - id: "X-3"
      name: "Advanced Cache Design"
      category: "Concurrency"
      difficulty: 9
      points: 7
      prompt: |
        Design a cache that:
        1. Concurrent reads, exclusive writes
        2. Prevents thundering herd on cache miss
        3. Bounded memory with LRU eviction
        4. TTL expiration
        Outline synchronization strategy and pitfalls.
      keywords: ["RWMutex", "singleflight", "LRU", "TTL", "thundering herd"]
      reasoning_required: true
      rubric: |
        7 pts: Complete design + pitfall analysis
        5-6 pts: Most requirements addressed
        3-4 pts: Basic cache, misses advanced features
        1-2 pts: Simple mutex cache only

# =============================================================================
# AMBIGUITY TESTS (10 points) - Tests clarification ability
# =============================================================================

ambiguity_tier:
  total_points: 10
  tests:
    - id: "A-1"
      name: "Vague Bug Report"
      category: "Clarification"
      difficulty: 2
      points: 3
      prompt: "The API is slow. Fix it."
      keywords: ["which", "how slow", "metrics", "clarify", "endpoint", "what"]
      anti_patterns: ["add cache", "optimize"]  # Jumping to solutions
      rubric: |
        3 pts: Asks 3+ clarifying questions
        2 pts: Asks 1-2 questions
        1 pt: Acknowledges need for info but still proposes
        0 pts: Jumps to solution

    - id: "A-2"
      name: "Underspecified Feature"
      category: "Clarification"
      difficulty: 2
      points: 3
      prompt: "Add authentication to the API."
      keywords: ["what type", "JWT", "OAuth", "requirements", "existing"]
      anti_patterns: ["here's how"]  # Assuming without asking
      rubric: |
        3 pts: Asks about type, infrastructure, requirements
        2 pts: Asks some questions
        1 pt: Mentions options but doesn't ask
        0 pts: Proposes without clarification

    - id: "A-3"
      name: "Contradictory Requirements"
      category: "Critical Thinking"
      difficulty: 4
      points: 4
      prompt: |
        Requirements:
        1. API must respond in <10ms for all requests
        2. All data must be fetched fresh from database (no caching)
        3. Database is in another region with 50ms latency
        Implement this feature.
      keywords: ["impossible", "contradiction", "cannot", "conflict", "trade-off"]
      rubric: |
        4 pts: Identifies logical impossibility, asks priority
        3 pts: Notes conflict but tries compromise
        2 pts: Mentions difficulty but attempts
        1 pt: Vague acknowledgment
        0 pts: Tries to implement impossible

# =============================================================================
# SCORING METHODOLOGY v2.0
# =============================================================================

scoring:
  version: "2.0"

  # Multi-dimensional scoring
  dimensions:
    correctness:
      weight: 40
      description: "Is the answer factually correct?"
    completeness:
      weight: 25
      description: "Are all aspects addressed?"
    reasoning:
      weight: 25
      description: "Is the logic chain valid?"
    conciseness:
      weight: 10
      description: "Appropriate length?"

  # Automated scoring weights
  automated:
    keyword_weight: 0.3
    reasoning_weight: 0.5
    format_weight: 0.2

  # Expected tier performance
  expected_performance:
    expert_model:  # opus
      easy: "95%+"
      medium: "85%+"
      hard: "70%+"
      expert: "50%+"
    strong_model:  # sonnet
      easy: "90%+"
      medium: "75%+"
      hard: "50%+"
      expert: "30%+"
    basic_model:  # haiku
      easy: "85%+"
      medium: "60%+"
      hard: "30%+"
      expert: "10%+"
    local_model:  # qwen3, deepseek
      easy: "70%+"
      medium: "40%+"
      hard: "15%+"
      expert: "5%+"

  # Target differentiation gaps
  differentiation:
    opus_vs_sonnet: "15-20% gap in hard/expert"
    sonnet_vs_haiku: "20-25% gap in medium/hard"
    cloud_vs_local: "30-40% overall gap"

# =============================================================================
# EXECUTION CONFIG
# =============================================================================

execution:
  timeout_per_test: 60
  max_retries: 2

  system_prompt: |
    You are being evaluated on reasoning quality.
    Think step by step. Explain your logic.
    Be concise but complete.
