# Algorithm Design: Two Sum

## Session Info

| Field | Value |
|-------|-------|
| Session ID | 2024-12-31-solve-two-sum |
| Date | 2024-12-31 |
| Mode | Problem Solving |
| Difficulty | Easy |
| Source | LeetCode #1 |

---

## Problem Statement

Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`. You may assume that each input would have exactly one solution, and you may not use the same element twice.

### Constraints

- 2 â‰¤ nums.length â‰¤ 10â´
- -10â¹ â‰¤ nums[i] â‰¤ 10â¹
- -10â¹ â‰¤ target â‰¤ 10â¹
- Only one valid answer exists

### Examples

```
Example 1:
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: nums[0] + nums[1] = 2 + 7 = 9

Example 2:
Input: nums = [3,2,4], target = 6
Output: [1,2]

Example 3:
Input: nums = [3,3], target = 6
Output: [0,1]
```

---

## Analysis

### Problem Classification

| Aspect | Value |
|--------|-------|
| Category | Hash Map / Two Pointers |
| Pattern | Complement lookup |
| Similar Problems | Two Sum II, 3Sum, 4Sum |

### Key Insight

Core observation: Vá»›i má»—i sá»‘ `nums[i]`, ta cáº§n tÃ¬m `complement = target - nums[i]`.

Mathematical intuition: `a + b = target` âŸº `b = target - a`

Thay vÃ¬ iterate qua táº¥t cáº£ j > i (O(nÂ²)), ta cÃ³ thá»ƒ dÃ¹ng Hash Map Ä‘á»ƒ O(1) lookup.

---

## Algorithm Design

### Approach: Hash Map (Complement Lookup)

**Strategy:**
1. Create empty hash map: seen = {}
2. For each (index, num) in nums:
   - complement = target - num
   - If complement in seen: return [seen[complement], index]
   - Else: seen[num] = index
3. Return [] (khÃ´ng tÃ¬m tháº¥y)

### Complexity Analysis

| Metric | Value | Justification |
|--------|-------|---------------|
| Time | O(n) | Single pass, hash O(1) lookup |
| Space | O(n) | Hash map stores up to n elements |

### Alternative Approaches Considered

| Approach | Time | Space | Why Not Chosen |
|----------|------|-------|----------------|
| Brute Force | O(nÂ²) | O(1) | Too slow for n=10â´ |
| Two Pointers (sort) | O(n log n) | O(n) | Need original indices |

---

## Implementation

### Code

```python
def two_sum(nums: list[int], target: int) -> list[int]:
    seen = {}  # value -> index

    for i, num in enumerate(nums):
        complement = target - num

        # Check if complement exists
        if complement in seen:
            return [seen[complement], i]

        # Add current number to map
        seen[num] = i

    return []  # No solution found
```

### Key Implementation Details

1. Check complement BEFORE adding to map (avoid using same element twice)
2. Store value â†’ index mapping for O(1) lookup
3. Return indices in order [earlier, later]

---

## Validation

### Edge Cases

| Case | Input | Expected | Actual | Status |
|------|-------|----------|--------|--------|
| Basic | [2,7,11,15], 9 | [0,1] | [0,1] | âœ… |
| Same values | [3,3], 6 | [0,1] | [0,1] | âœ… |
| Negative | [-1,-2,-3], -4 | [0,2] | [0,2] | âœ… |
| Large values | [10^9, -10^9], 0 | [0,1] | [0,1] | âœ… |
| End of array | [1,2,3,4], 7 | [2,3] | [2,3] | âœ… |

---

## Pitfalls to Avoid

- âŒ ThÃªm num vÃ o map TRÆ¯á»šC khi check â†’ cÃ³ thá»ƒ dÃ¹ng cÃ¹ng element 2 láº§n
- âŒ QuÃªn case [3,3] vá»›i target=6 â†’ cáº§n check complement trÆ°á»›c khi add
- âŒ Return sai thá»© tá»± indices

---

## Sign-off

| Agent | Status | Notes |
|-------|--------|-------|
| Developer ğŸ‘¨â€ğŸ’» | âœ… Approved | Implementation verified |
| Algo-Master ğŸ§™ | âœ… Approved | Optimal complexity |
| Code Reviewer ğŸ” | âœ… Approved | All edge cases handled |

---

## Key Learnings

- Two Sum lÃ  foundation pattern cho hash map lookup
- "Check before add" pattern prevents using same element twice
- Hash map trades O(n) space for O(1) lookup time

---

**Generated by Dev-Algo Team Simulation**
**Session Duration:** ~10 minutes
**Total Turns:** 5
