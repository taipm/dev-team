# Code Review Report: Longest Increasing Subsequence TLE

## Session Info

| Field | Value |
|-------|-------|
| Session ID | 2024-12-31-review-lis-tle |
| Date | 2024-12-31 |
| Mode | Code Review |
| Problem | LeetCode #300 - Longest Increasing Subsequence |

---

## Code Under Review

### Context

Developer submitted a backtracking solution that gets TLE on large test cases.

### Original Implementation

```python
def length_of_lis(nums):
    n = len(nums)
    if n == 0:
        return 0

    max_len = 1

    def backtrack(index, prev_val, length):
        nonlocal max_len
        max_len = max(max_len, length)

        for i in range(index, n):
            if nums[i] > prev_val:
                backtrack(i + 1, nums[i], length + 1)

    for i in range(n):
        backtrack(i + 1, nums[i], 1)

    return max_len
```

### Stated Complexity
- **Time:** "KhÃ´ng cháº¯c, cÃ³ láº½ O(2^n)?"
- **Space:** O(n) recursion depth

### Reported Issues
- Works on small inputs
- TLE khi n > 20

---

## Correctness Analysis

### Checklist

| Check | Status | Notes |
|-------|--------|-------|
| Base case handling | âœ… | Empty array returns 0 |
| Logic correctness | âœ… | Correct LIS logic |
| Return values | âœ… | Returns max length |

---

## Root Cause Analysis

### Complexity Verification

| Metric | Claimed | Actual | Impact |
|--------|---------|--------|--------|
| Time | O(2^n)? | **O(2^n)** | ðŸ”´ TLE |
| Space | O(n) | O(n) | âœ… OK |

### Why TLE?

```
Backtracking explores ALL possible subsequences:
- For each element: include or skip = 2 choices
- Decision tree has 2^n nodes
- n = 2500 â†’ 2^2500 operations ðŸ’€

Constraint allows O(nÂ²) = 6.25M operations.
```

### Issues Found

| # | Severity | Issue | Impact |
|---|----------|-------|--------|
| 1 | ðŸ”´ Critical | Exponential backtracking | TLE |
| 2 | ðŸŸ¡ Medium | No memoization | Repeated subproblems |
| 3 | ðŸŸ¢ Low | Unnecessary nonlocal | Style issue |

---

## Optimization Solutions

### Solution 1: DP O(nÂ²)

```python
def length_of_lis_dp(nums):
    if not nums:
        return 0

    n = len(nums)
    dp = [1] * n  # dp[i] = LIS length ending at i

    for i in range(1, n):
        for j in range(i):
            if nums[j] < nums[i]:
                dp[i] = max(dp[i], dp[j] + 1)

    return max(dp)
```

**Complexity:** Time O(nÂ²), Space O(n)

### Solution 2: Binary Search O(n log n)

```python
import bisect

def length_of_lis_optimal(nums):
    if not nums:
        return 0

    tails = []  # tails[i] = smallest tail of LIS with length i+1

    for num in nums:
        pos = bisect.bisect_left(tails, num)
        if pos == len(tails):
            tails.append(num)  # Extend LIS
        else:
            tails[pos] = num   # Replace with smaller tail

    return len(tails)
```

**Complexity:** Time O(n log n), Space O(n)

---

## Edge Case Testing

| Case | Input | Expected | DP | Binary | Status |
|------|-------|----------|----|---------|----|
| Empty | [] | 0 | 0 | 0 | âœ… |
| Single | [5] | 1 | 1 | 1 | âœ… |
| Increasing | [1,2,3,4,5] | 5 | 5 | 5 | âœ… |
| Decreasing | [5,4,3,2,1] | 1 | 1 | 1 | âœ… |
| Duplicates | [2,2,2,2] | 1 | 1 | 1 | âœ… |
| Mixed | [10,9,2,5,3,7] | 3 | 3 | 3 | âœ… |

---

## Improvement Summary

| Version | Time | Space | Status |
|---------|------|-------|--------|
| Original (backtrack) | O(2^n) | O(n) | âŒ TLE |
| DP | O(nÂ²) | O(n) | âœ… AC |
| Binary Search | O(n log n) | O(n) | âœ… Fast AC |

---

## Verdict

**Status:** âœ… RESOLVED

**Summary:** Refactored from exponential O(2^n) backtracking to optimal O(n log n) binary search solution.

---

## Sign-off

| Agent | Status | Notes |
|-------|--------|-------|
| Developer ðŸ‘¨â€ðŸ’» | âœ… Approved | Implemented both solutions |
| Algo-Master ðŸ§™ | âœ… Approved | Patterns correctly applied |
| Code Reviewer ðŸ” | âœ… Approved | All tests pass |

---

## Key Learnings

- Overlapping subproblems â†’ Use DP
- Monotonic property â†’ Binary search optimization
- "Smallest tail" insight enables O(n log n) LIS
- Always check constraints: n=2500 requires O(nÂ²) or better

---

**Generated by Dev-Algo Team Simulation**
**Session Duration:** ~15 minutes
**Total Turns:** 6
