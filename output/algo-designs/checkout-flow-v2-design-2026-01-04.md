# Checkout Flow - Function Design Report v2.0

> Generated by Algo Function Agent ğŸ§  v2.0
> Date: 2026-01-04
> Type: design + handoff

---

## Metadata

| Field | Value |
|-------|-------|
| Project | E-commerce Checkout Flow |
| Domain | Payment, Inventory, Data Access, Communication |
| Functions | 17 |
| Complexity | High |
| Target Agent | go-dev-agent |
| Version | 2.0 (Enhanced Contracts) |

---

## 1. Problem Analysis

### Entities
- **Cart**: items, quantities, prices
- **User**: address, payment methods, profile
- **Order**: created from cart, tracks fulfillment
- **Payment**: transaction with external gateway
- **Inventory**: stock levels, reservations
- **Shipping**: methods, rates, tracking

### Domains Involved
- **Data Access**: cart, order, inventory CRUD
- **Payment**: external gateway integration (Stripe, PayPal)
- **Communication**: confirmation emails, warehouse notifications

### Critical Concerns
- âš ï¸ **Atomicity**: Payment + Order creation must be atomic (Saga pattern)
- âš ï¸ **Idempotency**: Retry-safe payment processing required
- âš ï¸ **Concurrency**: Inventory race conditions when multiple users checkout
- âš ï¸ **Consistency**: What if payment succeeds but order creation fails?

---

## 2. Function Specifications (v2.0 Enhanced)

### 2.1 processCheckout (Orchestrator)

**Signature:**
```
processCheckout(cartId: UUID, userId: UUID, paymentMethod: PaymentMethod, shippingAddress: Address)
  â†’ Result<Order, CheckoutError>
```

**Contract:**
- Pre: cartId exists and belongs to userId
- Pre: paymentMethod is valid and active
- Pre: shippingAddress is deliverable
- Post(success): order created, payment captured, inventory decremented, cart cleared
- Post(failure): error âˆˆ {CART_EMPTY, INVALID_ADDRESS, PAYMENT_DECLINED, OUT_OF_STOCK, INTERNAL_ERROR}
- Invariant: No partial state - either complete success or full rollback

**Performance Contract (v2.0):**
```
Time Complexity:
    Best:  O(n) where n = cart items
    Avg:   O(n)
    Worst: O(n) + retry overhead

Space Complexity: O(n) for cart items in memory

I/O Profile:
    DB Reads:  3 (cart, user, inventory check)
    DB Writes: 4 (reservation, order, order_items, clear cart)
    Network:   2 (payment gateway: intent + confirm)

Latency Budget:
    P50: < 500ms (excluding payment gateway)
    P99: < 2000ms
    Max: < 5000ms (payment gateway timeout)

Resource Bounds:
    Memory: < 10KB per checkout
    CPU: Dominated by bcrypt/payment crypto
    Connections: 1 DB + 1 payment gateway
```

**Concurrency Contract (v2.0):**
```
Thread Safety: âœ“ Safe for concurrent calls (different carts)
              âš  Same cart: requires external serialization

Atomicity:
    - Inventory reservation + decrement MUST be atomic
    - Payment + Order creation uses Saga pattern
    - Rollback on any failure

Locking:
    Required: YES
    Type: Optimistic (inventory) + Distributed (payment idempotency)
    Scope: Row-level on inventory SKUs

Race Conditions:
    âš  Inventory check-then-reserve:
        Risk: Two users see "1 in stock", both try to buy
        Mitigation: Atomic decrement with version check

    âš  Payment double-submit:
        Risk: User clicks twice, charged twice
        Mitigation: Idempotency key per checkout attempt

Idempotency: YES
    Key: hash(cartId, userId, timestamp_bucket_5min)
    Window: 5 minutes
    Storage: Redis with TTL

Scalability:
    Horizontal: âœ“ Stateless orchestrator
    Vertical: Limited by DB connection pool
    Bottleneck: Payment gateway rate limits (1000/min)
```

---

### 2.2 validateCart

**Signature:**
```
validateCart(cartId: UUID) â†’ Result<Cart, ValidationError>
```

**Contract:**
- Pre: cartId is valid UUID format
- Post(success): cart is non-empty, all items exist, all prices current
- Post(failure): error âˆˆ {CART_NOT_FOUND, CART_EMPTY, ITEM_NOT_FOUND, PRICE_CHANGED}

**Performance Contract:**
```
Time: O(n) items
Space: O(n)
I/O: 1 DB read (with JOIN to products)
Latency: P99 < 50ms
```

**Concurrency Contract:**
```
Thread Safety: âœ“ Safe (read-only)
Atomicity: N/A (single read)
Idempotency: YES (pure query)
```

---

### 2.3 validateShippingAddress

**Signature:**
```
validateShippingAddress(address: Address) â†’ Result<ValidatedAddress, ValidationError>
```

**Contract:**
- Pre: address has required fields (street, city, country, postal)
- Post(success): address is complete and deliverable
- Post(failure): error âˆˆ {MISSING_FIELD, INVALID_POSTAL, NOT_DELIVERABLE}

**Performance Contract:**
```
Time: O(1)
Space: O(1)
I/O: 0 (in-memory validation) or 1 (address verification API)
Latency: P99 < 100ms (with external API) / < 5ms (local)
```

**Concurrency Contract:**
```
Thread Safety: âœ“ Safe (pure function or stateless API call)
Idempotency: YES
```

---

### 2.4 validatePaymentMethod

**Signature:**
```
validatePaymentMethod(method: PaymentMethod, userId: UUID) â†’ Result<ValidatedMethod, ValidationError>
```

**Contract:**
- Pre: method.id exists
- Post(success): method belongs to user, not expired, active
- Post(failure): error âˆˆ {METHOD_NOT_FOUND, NOT_OWNED, EXPIRED, INACTIVE}

**Performance Contract:**
```
Time: O(1)
Space: O(1)
I/O: 1 DB read
Latency: P99 < 30ms
```

**Concurrency Contract:**
```
Thread Safety: âœ“ Safe (read-only)
Idempotency: YES
```

---

### 2.5-2.8 Calculate Functions (Pure)

**calculateSubtotal, calculateTax, calculateShipping, calculateTotal**

**Common Contract Properties:**
```
Performance:
    Time: O(n) for subtotal/shipping, O(1) for tax/total
    Space: O(1)
    I/O: 0 (pure functions)
    Latency: < 1ms

Concurrency:
    Thread Safety: âœ“ Safe (pure, no side effects)
    Atomicity: N/A
    Idempotency: YES (deterministic)

Invariant: Same inputs always produce same outputs
```

---

### 2.9 checkInventory

**Signature:**
```
checkInventory(cart: Cart) â†’ Result<InventoryStatus, OutOfStockError>
```

**Contract:**
- Pre: cart.items is valid
- Post(success): all items have sufficient stock
- Post(failure): error contains list of out-of-stock items with available quantities

**Performance Contract:**
```
Time: O(n) items
Space: O(n)
I/O: 1 DB read (batch query on SKUs)
Latency: P99 < 50ms
```

**Concurrency Contract:**
```
Thread Safety: âœ“ Safe (read-only snapshot)
âš  WARNING: Stock may change between check and reserve
Mitigation: Use optimistic locking in reserveInventory
```

---

### 2.10 reserveInventory âš ï¸ CRITICAL

**Signature:**
```
reserveInventory(cart: Cart, reservationId: UUID) â†’ Result<Reservation, InventoryError>
```

**Contract:**
- Pre: inventory available (checkInventory passed)
- Post(success): stock decremented, reservation record created with TTL
- Post(failure): error âˆˆ {RACE_CONDITION, STOCK_CHANGED}

**Performance Contract:**
```
Time: O(n) items
Space: O(n)
I/O: n DB writes (transactional)
Latency: P99 < 100ms
```

**Concurrency Contract:**
```
Thread Safety: âš  Conditional - requires transaction isolation

Atomicity:
    - ALL items reserved or NONE
    - Use database transaction with SERIALIZABLE isolation
    - Alternative: Redis WATCH/MULTI for distributed

Locking:
    Required: YES
    Type: Optimistic with version field
    Implementation:
        UPDATE inventory
        SET quantity = quantity - :requested,
            version = version + 1
        WHERE sku = :sku
          AND quantity >= :requested
          AND version = :expected_version

Race Conditions:
    âš  Lost update on concurrent reservations:
        Risk: Two transactions read same stock, both succeed
        Mitigation: Version check fails second transaction

    âš  Phantom read:
        Risk: New reservation appears between check and reserve
        Mitigation: SERIALIZABLE isolation or SELECT FOR UPDATE

Idempotency: NO
    Risk: Calling twice reserves double
    Mitigation: Check reservationId doesn't exist before creating
```

---

### 2.11 releaseInventory

**Signature:**
```
releaseInventory(reservationId: UUID) â†’ void
```

**Contract:**
- Pre: reservationId exists
- Post: if reservation exists, stock restored
- Invariant: Idempotent - safe to call multiple times

**Performance Contract:**
```
Time: O(n) reserved items
Space: O(1)
I/O: n DB writes
Latency: P99 < 100ms
```

**Concurrency Contract:**
```
Thread Safety: âœ“ Safe
Atomicity: YES (transactional restore)
Idempotency: YES (check existence first)
```

---

### 2.12 createPaymentIntent âš ï¸ CRITICAL

**Signature:**
```
createPaymentIntent(total: Money, currency: Currency, idempotencyKey: string)
  â†’ Result<PaymentIntent, PaymentError>
```

**Contract:**
- Pre: total > 0, currency is supported
- Post(success): intent created with payment gateway
- Post(failure): error âˆˆ {GATEWAY_ERROR, INVALID_AMOUNT}

**Performance Contract:**
```
Time: O(1)
Space: O(1)
I/O: 1 external API call (Stripe/PayPal)
Latency:
    P50: < 300ms
    P99: < 1000ms
    Max: < 3000ms (with retry)
```

**Concurrency Contract:**
```
Thread Safety: âœ“ Safe (stateless API call)

Idempotency: YES (CRITICAL)
    Key: idempotencyKey parameter
    Implementation: Stripe handles this natively
    Behavior: Same key returns same intent, no duplicate

Network Resilience:
    Retry: 3 attempts with exponential backoff
    Timeout: 3s per attempt
    Circuit Breaker: Open after 5 failures in 30s
```

---

### 2.13 confirmPayment âš ï¸ CRITICAL

**Signature:**
```
confirmPayment(intentId: string, paymentMethod: PaymentMethod)
  â†’ Result<PaymentConfirmation, PaymentError>
```

**Contract:**
- Pre: intentId exists, paymentMethod valid
- Post(success): payment captured, confirmation received
- Post(failure): error âˆˆ {DECLINED, INSUFFICIENT_FUNDS, EXPIRED_CARD, NETWORK_ERROR}

**Performance Contract:**
```
Time: O(1)
Space: O(1)
I/O: 1 external API call
Latency:
    P50: < 500ms (includes 3DS if needed)
    P99: < 2000ms
    Max: < 5000ms
```

**Concurrency Contract:**
```
Thread Safety: âœ“ Safe

Idempotency: YES
    Stripe: Confirming already-confirmed intent returns success
    âš  Do NOT create new intent on retry

3D Secure Handling:
    If requires_action: return REQUIRES_3DS with client_secret
    Frontend completes 3DS, then call confirmPayment again
```

---

### 2.14 refundPayment

**Signature:**
```
refundPayment(paymentId: string, amount: Money?) â†’ Result<Refund, RefundError>
```

**Contract:**
- Pre: payment was successful
- Post(success): refund issued (full if amount nil, partial otherwise)
- Post(failure): error âˆˆ {ALREADY_REFUNDED, AMOUNT_TOO_HIGH, GATEWAY_ERROR}

**Performance Contract:**
```
Time: O(1)
I/O: 1 external API call
Latency: P99 < 1000ms
```

**Concurrency Contract:**
```
Idempotency: Partial - same refund amount on same payment is idempotent
             Different amounts create separate refunds
```

---

### 2.15 createOrder âš ï¸ CRITICAL

**Signature:**
```
createOrder(cart: Cart, userId: UUID, payment: PaymentConfirmation, shipping: ShippingInfo)
  â†’ Result<Order, OrderError>
```

**Contract:**
- Pre: payment successful, cart valid
- Post(success): order persisted with unique ID, status = CONFIRMED
- Post(failure): error âˆˆ {DB_ERROR}

**Performance Contract:**
```
Time: O(n) items
Space: O(n)
I/O: 1 DB transaction (order + n order_items)
Latency: P99 < 100ms
```

**Concurrency Contract:**
```
Thread Safety: âœ“ Safe (unique order ID)

Atomicity:
    - Order + OrderItems in single transaction
    - Include payment snapshot (don't reference payment table)

âš  CRITICAL: This MUST succeed after payment
    If DB fails: Queue for manual review + auto-retry
    Never leave payment captured without order

Idempotency: Conditional
    Check: If order exists with same paymentId, return existing
```

---

### 2.16-2.17 Notification Functions

**sendOrderConfirmation, notifyWarehouse**

**Contract:**
- Post: notification queued/sent
- Invariant: Async, fire-and-forget OK for email
- Invariant: notifyWarehouse should retry on failure

**Performance Contract:**
```
Time: O(1)
I/O: 1 queue write or API call
Latency: < 50ms (queue) / < 500ms (direct API)
```

**Concurrency Contract:**
```
Thread Safety: âœ“ Safe
Idempotency: YES (same orderId = skip duplicate)
Delivery: At-least-once for warehouse, best-effort for email
```

---

## 3. Dependency Graph

```
                            processCheckout
                                  â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚                       â”‚                       â”‚
          â–¼                       â–¼                       â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ VALIDATE  â”‚          â”‚ CALCULATE â”‚          â”‚ INVENTORY â”‚
    â”‚           â”‚          â”‚   (Pure)  â”‚          â”‚           â”‚
    â”‚ â€¢ cart    â”‚          â”‚           â”‚          â”‚ â€¢ check   â”‚
    â”‚ â€¢ address â”‚          â”‚ â€¢ subtotalâ”‚          â”‚ â€¢ reserve â”‚
    â”‚ â€¢ payment â”‚          â”‚ â€¢ tax     â”‚          â”‚ â€¢ release â”‚
    â”‚           â”‚          â”‚ â€¢ shippingâ”‚          â”‚ â€¢ finalizeâ”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚ â€¢ total   â”‚          â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
                                                        â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
          â”‚                                             â”‚
          â–¼                                             â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  PAYMENT  â”‚                               â”‚   ORDER   â”‚
    â”‚           â”‚                               â”‚           â”‚
    â”‚ â€¢ intent  â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ â€¢ create  â”‚
    â”‚ â€¢ confirm â”‚                               â”‚           â”‚
    â”‚ â€¢ refund  â”‚                               â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                     â”‚
          â”‚                                           â”‚
          â”‚                                           â–¼
          â”‚                                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ NOTIFICATIONS â”‚
                                              â”‚               â”‚
                                              â”‚ â€¢ email       â”‚
                                              â”‚ â€¢ warehouse   â”‚
                                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Implementation Order:**
1. **Pure functions first** (no deps): calculateSubtotal, calculateTax, calculateShipping, calculateTotal
2. **Validators**: validateCart, validateAddress, validatePaymentMethod
3. **Inventory**: checkInventory, reserveInventory, releaseInventory
4. **Payment**: createPaymentIntent, confirmPayment, refundPayment
5. **Order**: createOrder
6. **Notifications**: sendOrderConfirmation, notifyWarehouse
7. **Orchestrator last**: processCheckout

---

## 4. Annotated Pseudocode (v2.0)

```
function processCheckout(cartId, userId, paymentMethod, shippingAddress):
    // @complexity: O(n) where n = cart items
    // @transactions: 1 payment + 2-3 DB writes
    // @pattern: Saga with compensating transactions
    // @concurrency: Thread-safe per cart, idempotent with key

    idempotencyKey = generateIdempotencyKey(cartId, userId, timestamp)

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 1: VALIDATION (fail fast, pure checks)
    // @latency_budget: 100ms total
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    cart = validateCart(cartId)
    if cart.isError:
        return cart.error  // CART_EMPTY, CART_NOT_FOUND, ITEM_INVALID

    address = validateShippingAddress(shippingAddress)
    if address.isError:
        return address.error  // ADDRESS_INVALID, NOT_DELIVERABLE

    payment = validatePaymentMethod(paymentMethod, userId)
    if payment.isError:
        return payment.error  // METHOD_EXPIRED, NOT_OWNED

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 2: CALCULATION (pure functions, no side effects)
    // @latency_budget: 10ms total
    // @concurrency: Safe to parallelize
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    subtotal = calculateSubtotal(cart)
    tax = calculateTax(subtotal, address)
    shipping = calculateShipping(cart, address, shippingMethod)
    discounts = applyDiscounts(cart, userId)
    total = calculateTotal(subtotal, tax, shipping, discounts)

    // @invariant: total > 0

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 3: INVENTORY RESERVATION
    // @rollback: releaseInventory if later steps fail
    // @concurrency: Optimistic locking with version check
    // @latency_budget: 100ms
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    inventoryCheck = checkInventory(cart)
    if inventoryCheck.isError:
        return inventoryCheck.error  // OUT_OF_STOCK with item details

    reservationId = generateUUID()
    reservation = reserveInventory(cart, reservationId)
    if reservation.isError:
        // @concurrency: Race condition detected
        return reservation.error  // RACE_CONDITION, STOCK_CHANGED

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 4: PAYMENT PROCESSING
    // @rollback: releaseInventory if payment fails
    // @idempotency: same idempotencyKey = same result
    // @latency_budget: 2000ms (external API)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    paymentIntent = createPaymentIntent(total, currency, idempotencyKey)
    if paymentIntent.isError:
        releaseInventory(reservationId)  // COMPENSATE
        return paymentIntent.error

    paymentResult = confirmPayment(paymentIntent.id, paymentMethod)
    if paymentResult.isError:
        releaseInventory(reservationId)  // COMPENSATE
        return paymentResult.error  // DECLINED, INSUFFICIENT_FUNDS

    // @checkpoint: Payment successful, must complete order

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 5: ORDER CREATION
    // @critical: This must succeed after payment
    // @retry: With exponential backoff if DB fails
    // @idempotency: Check existing order with same paymentId
    // @latency_budget: 100ms
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    order = createOrder(
        cart: cart,
        user: userId,
        payment: paymentResult,
        shipping: {address, method, cost: shipping},
        totals: {subtotal, tax, shipping, discounts, total}
    )

    if order.isError:
        // @critical: Payment succeeded but order failed
        // Queue for manual review + refund
        queueForManualReview(paymentResult, cart, "ORDER_CREATION_FAILED")
        return Error(INTERNAL_ERROR, "Please contact support. Ref: " + paymentResult.id)

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 6: FINALIZATION (async OK, non-critical)
    // @concurrency: Fire-and-forget with at-least-once delivery
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    finalizeInventory(reservationId, order.id)
    clearCart(cartId)

    // @async: These can fail without affecting user experience
    go sendOrderConfirmation(order, userId)
    go notifyWarehouse(order)

    return Success(order)
```

---

## 5. Abstraction Leak Warnings (v2.0 Enhanced)

| Type | Abstract | Reality | Mitigation | Severity |
|------|----------|---------|------------|----------|
| **Concurrency** | `reserveInventory()` decrements stock | Multiple users buying last item simultaneously causes race condition | Use optimistic locking with version check OR distributed lock (Redis) | ğŸ”´ HIGH |
| **Atomicity** | Pay then create order | Payment succeeds but DB write fails = money taken, no order | Saga pattern: queue failed orders for manual review + auto-refund | ğŸ”´ HIGH |
| **Idempotency** | `confirmPayment()` charges card | Network timeout - did it succeed or not? Retry might double-charge | Use idempotency key from payment gateway, check status before retry | ğŸ”´ HIGH |
| **Consistency** | Inventory reserved | Reservation times out if order never finalizes | Background job to clean up stale reservations (TTL-based) | ğŸŸ¡ MEDIUM |
| **Network** | External API calls | Payment gateway timeout | Circuit breaker pattern, exponential backoff retry | ğŸŸ¡ MEDIUM |
| **Performance** | O(n) checkout | Cart with 100+ items may timeout | Batch operations, consider cart size limits | ğŸŸ¡ MEDIUM |
| **Scalability** | Horizontal scaling | DB connection pool exhaustion under load | Connection pooling, read replicas for validation | ğŸŸ¡ MEDIUM |

---

## 6. Open Questions

- [ ] **Session storage**: Redis or PostgreSQL for inventory reservations?
- [ ] **Reservation TTL**: 10 minutes or 15 minutes before auto-release?
- [ ] **Rate limits**: 5 checkouts/min per user or no limit?
- [ ] **3D Secure**: Required for all cards or only flagged transactions?
- [ ] **Partial checkout**: Allow checkout if some items out of stock?
- [ ] **Price lock**: Lock prices at cart add time or checkout time?
- [ ] **Tax calculation**: In-house rules or external service (Avalara)?

---

## 7. Handoff Summary

**Ready for:** go-dev-agent
**Functions to implement:** 17
**External dependencies:**
- Payment gateway SDK (Stripe recommended)
- Email service (SendGrid/SES)
- Database (PostgreSQL with row-level locking)
- Optional: Redis for reservations

**Estimated effort:** Medium-High
**Critical path:** Payment + Order creation atomicity

---

## 8. Framework Mappings (Go)

| Abstract Function | Go Implementation |
|-------------------|-------------------|
| Money type | `shopspring/decimal` or custom Money struct |
| UUID | `github.com/google/uuid` |
| Payment gateway | `github.com/stripe/stripe-go/v76` |
| Database | `database/sql` + `github.com/lib/pq` or GORM |
| Email | `github.com/sendgrid/sendgrid-go` |
| Distributed lock | `github.com/go-redis/redis/v9` with SETNX |
| Queue | `github.com/hibiken/asynq` (Redis-based) |
| Circuit breaker | `github.com/sony/gobreaker` |

---

## 9. Test Templates (v2.0 NEW)

### Generated from Contracts

```go
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TEST TEMPLATES - Generated from algo-function-agent v2.0 contracts
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// === PRE-CONDITION TESTS: processCheckout ===

func TestProcessCheckout_RejectsEmptyCart(t *testing.T) {
    // Pre: cartId exists and belongs to userId
    emptyCart := createEmptyCart(userId)
    result := processCheckout(emptyCart.ID, userId, validPayment, validAddress)

    assert.Error(t, result.Err)
    assert.Equal(t, CART_EMPTY, result.Err.Code)
}

func TestProcessCheckout_RejectsInvalidPaymentMethod(t *testing.T) {
    // Pre: paymentMethod is valid and active
    expiredPayment := createExpiredPaymentMethod(userId)
    result := processCheckout(validCart.ID, userId, expiredPayment, validAddress)

    assert.Error(t, result.Err)
    assert.Equal(t, METHOD_EXPIRED, result.Err.Code)
}

func TestProcessCheckout_RejectsNonDeliverableAddress(t *testing.T) {
    // Pre: shippingAddress is deliverable
    invalidAddress := Address{Country: "XX", Postal: "00000"}
    result := processCheckout(validCart.ID, userId, validPayment, invalidAddress)

    assert.Error(t, result.Err)
    assert.Equal(t, NOT_DELIVERABLE, result.Err.Code)
}

// === POST-CONDITION TESTS: processCheckout ===

func TestProcessCheckout_Success_CreatesOrder(t *testing.T) {
    // Post(success): order created, payment captured, inventory decremented
    result := processCheckout(validCart.ID, userId, validPayment, validAddress)

    assert.NoError(t, result.Err)
    assert.NotEmpty(t, result.Value.ID)
    assert.Equal(t, ORDER_CONFIRMED, result.Value.Status)

    // Verify inventory decremented
    for _, item := range validCart.Items {
        stock := getInventory(item.SKU)
        assert.Equal(t, originalStock[item.SKU] - item.Quantity, stock)
    }

    // Verify cart cleared
    cart := getCart(validCart.ID)
    assert.Empty(t, cart.Items)
}

func TestProcessCheckout_Failure_RollbacksInventory(t *testing.T) {
    // Post(failure): full rollback
    mockPaymentGateway.FailNextConfirm(DECLINED)
    originalStock := getInventorySnapshot()

    result := processCheckout(validCart.ID, userId, validPayment, validAddress)

    assert.Error(t, result.Err)
    assert.Equal(t, PAYMENT_DECLINED, result.Err.Code)

    // Verify inventory NOT changed
    currentStock := getInventorySnapshot()
    assert.Equal(t, originalStock, currentStock)
}

// === INVARIANT TESTS ===

func TestProcessCheckout_NoPartialState(t *testing.T) {
    // Invariant: No partial state - either complete success or full rollback

    // Simulate failure at various points
    failurePoints := []string{"after_reserve", "after_payment", "during_order"}

    for _, failAt := range failurePoints {
        t.Run(failAt, func(t *testing.T) {
            injectFailure(failAt)
            originalState := captureSystemState()

            result := processCheckout(validCart.ID, userId, validPayment, validAddress)

            if result.IsError() {
                currentState := captureSystemState()
                // State should be unchanged or fully rolled back
                assertStateConsistent(t, originalState, currentState)
            }
        })
    }
}

// === PERFORMANCE TESTS ===

func BenchmarkProcessCheckout_MeetsLatencyBudget(b *testing.B) {
    // Performance: P99 < 2000ms
    var latencies []time.Duration

    for i := 0; i < b.N; i++ {
        cart := createCartWithItems(10)
        start := time.Now()
        processCheckout(cart.ID, userId, validPayment, validAddress)
        latencies = append(latencies, time.Since(start))
    }

    p99 := percentile(latencies, 0.99)
    assert.Less(b, p99, 2000*time.Millisecond, "P99 latency exceeded budget")
}

// === CONCURRENCY TESTS ===

func TestReserveInventory_RaceCondition(t *testing.T) {
    // Concurrency: Race condition on last item
    sku := "LIMITED-ITEM"
    setInventory(sku, 1)  // Only 1 in stock

    var wg sync.WaitGroup
    var successCount atomic.Int32

    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            cart := createCartWithSKU(sku, 1)
            result := reserveInventory(cart, uuid.New())
            if result.IsSuccess() {
                successCount.Add(1)
            }
        }()
    }

    wg.Wait()

    // Only ONE should succeed
    assert.Equal(t, int32(1), successCount.Load())

    // Stock should be 0
    assert.Equal(t, 0, getInventory(sku))
}

func TestProcessCheckout_Idempotency(t *testing.T) {
    // Concurrency: Idempotency with same key
    idempotencyKey := "test-key-123"

    // First call
    result1 := processCheckoutWithKey(validCart.ID, userId, validPayment, validAddress, idempotencyKey)
    assert.NoError(t, result1.Err)

    // Second call with same key (retry scenario)
    result2 := processCheckoutWithKey(validCart.ID, userId, validPayment, validAddress, idempotencyKey)
    assert.NoError(t, result2.Err)

    // Should return same order, NOT create duplicate
    assert.Equal(t, result1.Value.ID, result2.Value.ID)

    // Payment should only be captured once
    assert.Equal(t, 1, mockPaymentGateway.GetChargeCount())
}

func TestProcessCheckout_ConcurrentDifferentCarts(t *testing.T) {
    // Concurrency: Thread-safe for different carts
    var wg sync.WaitGroup
    results := make(chan *CheckoutResult, 100)

    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func(userNum int) {
            defer wg.Done()
            userId := fmt.Sprintf("user-%d", userNum)
            cart := createCartForUser(userId)
            result := processCheckout(cart.ID, userId, validPayment, validAddress)
            results <- result
        }(i)
    }

    wg.Wait()
    close(results)

    // All should succeed (no interference)
    successCount := 0
    for result := range results {
        if result.IsSuccess() {
            successCount++
        }
    }

    assert.Equal(t, 100, successCount)
}
```

---

## 10. Incremental Handoff Plan (v2.0 NEW)

```yaml
incremental_handoff:
  project: "checkout-flow"
  total_phases: 4
  target_agent: go-dev-agent

  phase_1_foundation:
    name: "Pure Functions & Types"
    functions:
      - calculateSubtotal
      - calculateTax
      - calculateShipping
      - calculateTotal
      - Money type definition
      - Error types definition
    tests_required:
      - calculation_test.go
      - money_test.go
    estimated_effort: "low"
    dependencies: []
    acceptance_criteria:
      - All pure functions implemented
      - Unit tests passing with 100% coverage
      - No external dependencies
      - Handles edge cases (zero, negative, overflow)

  phase_2_validators:
    name: "Validation Layer"
    functions:
      - validateCart
      - validateShippingAddress
      - validatePaymentMethod
    tests_required:
      - validation_test.go
    estimated_effort: "low-medium"
    dependencies:
      - Database read access
      - Cart model
      - User model
    acceptance_criteria:
      - All validators implemented
      - Proper error messages
      - DB queries optimized
    blocking_for_phase_3:
      - validateCart
      - validatePaymentMethod

  phase_3_inventory:
    name: "Inventory Management"
    functions:
      - checkInventory
      - reserveInventory
      - releaseInventory
      - finalizeInventory
    tests_required:
      - inventory_test.go
      - inventory_concurrency_test.go
    estimated_effort: "medium-high"
    dependencies:
      - Database write access
      - Transaction support
      - Optional: Redis for distributed locking
    acceptance_criteria:
      - Optimistic locking implemented
      - Race condition tests passing
      - TTL-based reservation cleanup
    critical_notes:
      - "âš ï¸ Must handle concurrent reservations correctly"
      - "âš ï¸ Test with high concurrency (100+ goroutines)"
    blocking_for_phase_4:
      - reserveInventory
      - releaseInventory

  phase_4_payment:
    name: "Payment Integration"
    functions:
      - createPaymentIntent
      - confirmPayment
      - refundPayment
    tests_required:
      - payment_test.go
      - payment_integration_test.go
    estimated_effort: "medium"
    dependencies:
      - Stripe SDK
      - Idempotency key storage
    acceptance_criteria:
      - Stripe integration working
      - Idempotency tested
      - 3D Secure flow handled
      - Error recovery tested
    critical_notes:
      - "âš ï¸ Use Stripe test mode for development"
      - "âš ï¸ Never log card details"
    blocking_for_phase_5:
      - confirmPayment

  phase_5_order:
    name: "Order Creation"
    functions:
      - createOrder
      - sendOrderConfirmation
      - notifyWarehouse
    tests_required:
      - order_test.go
      - notification_test.go
    estimated_effort: "medium"
    dependencies:
      - All previous phases
      - Email service (SendGrid)
      - Queue system (asynq)
    acceptance_criteria:
      - Order creation atomic
      - Email queued correctly
      - Warehouse notification with retry

  phase_6_orchestrator:
    name: "Main Orchestrator"
    functions:
      - processCheckout
    tests_required:
      - checkout_test.go
      - checkout_integration_test.go
      - checkout_e2e_test.go
    estimated_effort: "medium"
    dependencies:
      - All previous phases
    acceptance_criteria:
      - Full Saga pattern implemented
      - Rollback tested at every failure point
      - Idempotency working
      - Performance benchmarks passing
    critical_notes:
      - "âš ï¸ Integration test required before deployment"
      - "âš ï¸ Load test with concurrent checkouts"
```

---

## 11. Feedback Protocol Setup

```yaml
feedback_protocol:
  from: go-dev-agent
  to: algo-function-agent

  channels:
    spec_clarification:
      use_when: "Spec is ambiguous or incomplete"
      example: |
        function: reserveInventory
        issue: "Spec doesn't specify behavior when partial stock available"
        proposal: "Reserve available quantity and return partial success"

    spec_amendment:
      use_when: "Implementation discovers missing requirement"
      requires_approval: true
      example: |
        function: createOrder
        issue: "Need to handle duplicate order creation gracefully"
        proposal: "Add idempotency check on paymentId"
        breaking_change: false

    implementation_deviation:
      use_when: "Must differ from spec for practical reasons"
      severity_levels: [minor, major, breaking]
      example: |
        function: confirmPayment
        issue: "Stripe webhook preferred over polling for 3DS"
        deviation: "Using webhook-based confirmation"
        severity: minor
        reason: "Better reliability and lower latency"
```

---

*Generated by Algo Function Agent v2.0*
*Enhanced with Performance Contracts, Concurrency Contracts, Test Templates, and Incremental Handoff*
