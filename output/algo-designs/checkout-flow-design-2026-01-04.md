# Checkout Flow - Function Design Report

> Generated by Algo Function Agent ğŸ§ 
> Date: 2026-01-04
> Type: design

---

## Metadata

| Field | Value |
|-------|-------|
| Project | E-commerce Checkout Flow |
| Domain | Payment, Inventory, Data Access, Communication |
| Functions | 17 |
| Complexity | High |
| Target Agent | go-dev-agent |

---

## 1. Problem Analysis

### Entities
- **Cart**: items, quantities, prices
- **User**: address, payment methods, profile
- **Order**: created from cart, tracks fulfillment
- **Payment**: transaction with external gateway
- **Inventory**: stock levels, reservations
- **Shipping**: methods, rates, tracking

### Domains Involved
- **Data Access**: cart, order, inventory CRUD
- **Payment**: external gateway integration (Stripe, PayPal)
- **Communication**: confirmation emails, warehouse notifications

### Critical Concerns
- âš ï¸ **Atomicity**: Payment + Order creation must be atomic (Saga pattern)
- âš ï¸ **Idempotency**: Retry-safe payment processing required
- âš ï¸ **Concurrency**: Inventory race conditions when multiple users checkout
- âš ï¸ **Consistency**: What if payment succeeds but order creation fails?

---

## 2. Function Specifications

### 2.1 processCheckout (Orchestrator)

**Signature:**
```
processCheckout(cartId: UUID, userId: UUID, paymentMethod: PaymentMethod, shippingAddress: Address)
  â†’ Result<Order, CheckoutError>
```

**Contract:**
- Pre: cartId exists and belongs to userId
- Pre: paymentMethod is valid and active
- Pre: shippingAddress is deliverable
- Post(success): order created, payment captured, inventory decremented, cart cleared
- Post(failure): error âˆˆ {CART_EMPTY, INVALID_ADDRESS, PAYMENT_DECLINED, OUT_OF_STOCK, INTERNAL_ERROR}
- Invariant: No partial state - either complete success or full rollback

**Complexity:** O(n) where n = cart items
**I/O:** 1 payment API + 3-5 DB operations

---

### 2.2 validateCart

**Signature:**
```
validateCart(cartId: UUID) â†’ Result<Cart, ValidationError>
```

**Contract:**
- Pre: cartId is valid UUID format
- Post(success): cart is non-empty, all items exist, all prices current
- Post(failure): error âˆˆ {CART_NOT_FOUND, CART_EMPTY, ITEM_NOT_FOUND, PRICE_CHANGED}

**Complexity:** O(n) items
**I/O:** 1 DB read

---

### 2.3 validateShippingAddress

**Signature:**
```
validateShippingAddress(address: Address) â†’ Result<ValidatedAddress, ValidationError>
```

**Contract:**
- Pre: address has required fields (street, city, country, postal)
- Post(success): address is complete and deliverable
- Post(failure): error âˆˆ {MISSING_FIELD, INVALID_POSTAL, NOT_DELIVERABLE}

**Complexity:** O(1)

---

### 2.4 validatePaymentMethod

**Signature:**
```
validatePaymentMethod(method: PaymentMethod, userId: UUID) â†’ Result<ValidatedMethod, ValidationError>
```

**Contract:**
- Pre: method.id exists
- Post(success): method belongs to user, not expired, active
- Post(failure): error âˆˆ {METHOD_NOT_FOUND, NOT_OWNED, EXPIRED, INACTIVE}

**Complexity:** O(1)
**I/O:** 1 DB read

---

### 2.5 calculateSubtotal

**Signature:**
```
calculateSubtotal(cart: Cart) â†’ Money
```

**Contract:**
- Pre: cart.items is non-empty
- Post: result = sum(item.price * item.quantity) for all items
- Invariant: Pure function, no side effects

**Complexity:** O(n) items

---

### 2.6 calculateTax

**Signature:**
```
calculateTax(subtotal: Money, address: Address) â†’ Money
```

**Contract:**
- Pre: subtotal >= 0, address has country/state
- Post: tax calculated based on jurisdiction rules
- Invariant: Pure function

**Complexity:** O(1) with tax table lookup

---

### 2.7 calculateShipping

**Signature:**
```
calculateShipping(cart: Cart, address: Address, method: ShippingMethod) â†’ Money
```

**Contract:**
- Pre: cart has items with weights
- Post: shipping cost based on weight/distance/method
- Invariant: Pure function

**Complexity:** O(n) items for weight calculation

---

### 2.8 calculateTotal

**Signature:**
```
calculateTotal(subtotal: Money, tax: Money, shipping: Money, discounts: Money) â†’ Money
```

**Contract:**
- Pre: all inputs >= 0
- Post: total = subtotal + tax + shipping - discounts
- Post: total >= 0 (discounts cannot exceed subtotal)
- Invariant: Pure function

**Complexity:** O(1)

---

### 2.9 checkInventory

**Signature:**
```
checkInventory(cart: Cart) â†’ Result<InventoryStatus, OutOfStockError>
```

**Contract:**
- Pre: cart.items is valid
- Post(success): all items have sufficient stock
- Post(failure): error contains list of out-of-stock items with available quantities

**Complexity:** O(n) items
**I/O:** n DB reads (can batch)

---

### 2.10 reserveInventory

**Signature:**
```
reserveInventory(cart: Cart, reservationId: UUID) â†’ Result<Reservation, InventoryError>
```

**Contract:**
- Pre: inventory available (checkInventory passed)
- Post(success): stock decremented, reservation record created with TTL
- Post(failure): error âˆˆ {RACE_CONDITION, STOCK_CHANGED}
- âš ï¸ CONCURRENCY: Use optimistic locking or distributed lock

**Complexity:** O(n) items
**I/O:** n DB writes (transactional)

**Implementation Notes:**
- Use database transaction with row-level locking
- Alternative: Redis distributed lock per SKU

---

### 2.11 releaseInventory

**Signature:**
```
releaseInventory(reservationId: UUID) â†’ void
```

**Contract:**
- Pre: reservationId exists
- Post: if reservation exists, stock restored
- Invariant: Idempotent - safe to call multiple times

**Complexity:** O(n) items
**I/O:** n DB writes

---

### 2.12 createPaymentIntent

**Signature:**
```
createPaymentIntent(total: Money, currency: Currency, idempotencyKey: string)
  â†’ Result<PaymentIntent, PaymentError>
```

**Contract:**
- Pre: total > 0, currency is supported
- Post(success): intent created with payment gateway
- Post(failure): error âˆˆ {GATEWAY_ERROR, INVALID_AMOUNT}
- âš ï¸ IDEMPOTENCY: Same key returns same intent (no duplicate charges)

**Complexity:** O(1)
**I/O:** 1 external API call

**Implementation Notes:**
- Use Stripe's built-in idempotency key support
- Generate key as hash(cartId, userId, timestamp_bucket)

---

### 2.13 confirmPayment

**Signature:**
```
confirmPayment(intentId: string, paymentMethod: PaymentMethod)
  â†’ Result<PaymentConfirmation, PaymentError>
```

**Contract:**
- Pre: intentId exists, paymentMethod valid
- Post(success): payment captured, confirmation received
- Post(failure): error âˆˆ {DECLINED, INSUFFICIENT_FUNDS, EXPIRED_CARD, NETWORK_ERROR}

**Complexity:** O(1)
**I/O:** 1 external API call

**Implementation Notes:**
- Handle 3D Secure if required
- Retry with exponential backoff on network errors

---

### 2.14 refundPayment

**Signature:**
```
refundPayment(paymentId: string, amount: Money?) â†’ Result<Refund, RefundError>
```

**Contract:**
- Pre: payment was successful
- Post(success): refund issued (full if amount nil, partial otherwise)
- Post(failure): error âˆˆ {ALREADY_REFUNDED, AMOUNT_TOO_HIGH, GATEWAY_ERROR}

**Complexity:** O(1)
**I/O:** 1 external API call

---

### 2.15 createOrder

**Signature:**
```
createOrder(cart: Cart, userId: UUID, payment: PaymentConfirmation, shipping: ShippingInfo)
  â†’ Result<Order, OrderError>
```

**Contract:**
- Pre: payment successful, cart valid
- Post(success): order persisted with unique ID, status = CONFIRMED
- Post(failure): error âˆˆ {DB_ERROR}

**Complexity:** O(n) items
**I/O:** 1 DB write (transactional with line items)

**Implementation Notes:**
- This MUST succeed after payment - queue for manual review if fails
- Include all pricing snapshot (don't reference cart)

---

### 2.16 sendOrderConfirmation

**Signature:**
```
sendOrderConfirmation(order: Order, userId: UUID) â†’ void
```

**Contract:**
- Post: email queued for delivery
- Invariant: Async, fire-and-forget OK

**Complexity:** O(1)
**I/O:** 1 queue write or email API call

---

### 2.17 notifyWarehouse

**Signature:**
```
notifyWarehouse(order: Order) â†’ void
```

**Contract:**
- Post: fulfillment system notified
- Invariant: Should retry on failure (use queue)

**Complexity:** O(1)
**I/O:** 1 external API or queue

---

## 3. Dependency Graph

```
                            processCheckout
                                  â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚                       â”‚                       â”‚
          â–¼                       â–¼                       â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ VALIDATE  â”‚          â”‚ CALCULATE â”‚          â”‚ INVENTORY â”‚
    â”‚           â”‚          â”‚   (Pure)  â”‚          â”‚           â”‚
    â”‚ â€¢ cart    â”‚          â”‚           â”‚          â”‚ â€¢ check   â”‚
    â”‚ â€¢ address â”‚          â”‚ â€¢ subtotalâ”‚          â”‚ â€¢ reserve â”‚
    â”‚ â€¢ payment â”‚          â”‚ â€¢ tax     â”‚          â”‚ â€¢ release â”‚
    â”‚           â”‚          â”‚ â€¢ shippingâ”‚          â”‚ â€¢ finalizeâ”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚ â€¢ total   â”‚          â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
                                                        â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
          â”‚                                             â”‚
          â–¼                                             â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  PAYMENT  â”‚                               â”‚   ORDER   â”‚
    â”‚           â”‚                               â”‚           â”‚
    â”‚ â€¢ intent  â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ â€¢ create  â”‚
    â”‚ â€¢ confirm â”‚                               â”‚           â”‚
    â”‚ â€¢ refund  â”‚                               â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                     â”‚
          â”‚                                           â”‚
          â”‚                                           â–¼
          â”‚                                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ NOTIFICATIONS â”‚
                                              â”‚               â”‚
                                              â”‚ â€¢ email       â”‚
                                              â”‚ â€¢ warehouse   â”‚
                                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Implementation Order:**
1. **Pure functions first** (no deps): calculateSubtotal, calculateTax, calculateShipping, calculateTotal
2. **Validators**: validateCart, validateAddress, validatePaymentMethod
3. **Inventory**: checkInventory, reserveInventory, releaseInventory
4. **Payment**: createPaymentIntent, confirmPayment, refundPayment
5. **Order**: createOrder
6. **Notifications**: sendOrderConfirmation, notifyWarehouse
7. **Orchestrator last**: processCheckout

---

## 4. Annotated Pseudocode

```
function processCheckout(cartId, userId, paymentMethod, shippingAddress):
    // @complexity: O(n) where n = cart items
    // @transactions: 1 payment + 2-3 DB writes
    // @pattern: Saga with compensating transactions

    idempotencyKey = generateIdempotencyKey(cartId, userId, timestamp)

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 1: VALIDATION (fail fast)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    cart = validateCart(cartId)
    if cart.isError:
        return cart.error  // CART_EMPTY, CART_NOT_FOUND, ITEM_INVALID

    address = validateShippingAddress(shippingAddress)
    if address.isError:
        return address.error  // ADDRESS_INVALID, NOT_DELIVERABLE

    payment = validatePaymentMethod(paymentMethod, userId)
    if payment.isError:
        return payment.error  // METHOD_EXPIRED, NOT_OWNED

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 2: CALCULATION (pure functions, no side effects)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    subtotal = calculateSubtotal(cart)
    tax = calculateTax(subtotal, address)
    shipping = calculateShipping(cart, address, shippingMethod)
    discounts = applyDiscounts(cart, userId)
    total = calculateTotal(subtotal, tax, shipping, discounts)

    // @invariant: total > 0

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 3: INVENTORY RESERVATION
    // @rollback: releaseInventory if later steps fail
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    inventoryCheck = checkInventory(cart)
    if inventoryCheck.isError:
        return inventoryCheck.error  // OUT_OF_STOCK with item details

    reservationId = generateUUID()
    reservation = reserveInventory(cart, reservationId)
    if reservation.isError:
        return reservation.error  // RACE_CONDITION, STOCK_CHANGED

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 4: PAYMENT PROCESSING
    // @rollback: releaseInventory if payment fails
    // @idempotency: same idempotencyKey = same result
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    paymentIntent = createPaymentIntent(total, currency, idempotencyKey)
    if paymentIntent.isError:
        releaseInventory(reservationId)  // COMPENSATE
        return paymentIntent.error

    paymentResult = confirmPayment(paymentIntent.id, paymentMethod)
    if paymentResult.isError:
        releaseInventory(reservationId)  // COMPENSATE
        return paymentResult.error  // DECLINED, INSUFFICIENT_FUNDS

    // @checkpoint: Payment successful, must complete order

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 5: ORDER CREATION
    // @critical: This must succeed after payment
    // @retry: With exponential backoff if DB fails
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    order = createOrder(
        cart: cart,
        user: userId,
        payment: paymentResult,
        shipping: {address, method, cost: shipping},
        totals: {subtotal, tax, shipping, discounts, total}
    )

    if order.isError:
        // @critical: Payment succeeded but order failed
        // Queue for manual review + refund
        queueForManualReview(paymentResult, cart, "ORDER_CREATION_FAILED")
        return Error(INTERNAL_ERROR, "Please contact support. Ref: " + paymentResult.id)

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 6: FINALIZATION (async OK)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    finalizeInventory(reservationId, order.id)
    clearCart(cartId)

    // @async: These can fail without affecting user experience
    go sendOrderConfirmation(order, userId)
    go notifyWarehouse(order)

    return Success(order)
```

---

## 5. Abstraction Leak Warnings

| Type | Abstract | Reality | Mitigation |
|------|----------|---------|------------|
| **Concurrency** | `reserveInventory()` decrements stock | Multiple users buying last item simultaneously causes race condition | Use optimistic locking with version check OR distributed lock (Redis) |
| **Atomicity** | Pay then create order | Payment succeeds but DB write fails = money taken, no order | Saga pattern: queue failed orders for manual review + auto-refund |
| **Idempotency** | `confirmPayment()` charges card | Network timeout - did it succeed or not? Retry might double-charge | Use idempotency key from payment gateway, check status before retry |
| **Consistency** | Inventory reserved | Reservation times out if order never finalizes | Background job to clean up stale reservations (TTL-based) |
| **Network** | External API calls | Payment gateway timeout | Circuit breaker pattern, exponential backoff retry |

---

## 6. Open Questions

- [ ] **Session storage**: Redis or PostgreSQL for inventory reservations?
- [ ] **Reservation TTL**: 10 minutes or 15 minutes before auto-release?
- [ ] **Rate limits**: 5 checkouts/min per user or no limit?
- [ ] **3D Secure**: Required for all cards or only flagged transactions?
- [ ] **Partial checkout**: Allow checkout if some items out of stock?
- [ ] **Price lock**: Lock prices at cart add time or checkout time?
- [ ] **Tax calculation**: In-house rules or external service (Avalara)?

---

## 7. Handoff Summary

**Ready for:** go-dev-agent
**Functions to implement:** 17
**External dependencies:**
- Payment gateway SDK (Stripe recommended)
- Email service (SendGrid/SES)
- Database (PostgreSQL with row-level locking)
- Optional: Redis for reservations

**Estimated effort:** Medium-High
**Critical path:** Payment + Order creation atomicity

---

## 8. Framework Mappings (Go)

| Abstract Function | Go Implementation |
|-------------------|-------------------|
| Money type | `shopspring/decimal` or custom Money struct |
| UUID | `github.com/google/uuid` |
| Payment gateway | `github.com/stripe/stripe-go/v76` |
| Database | `database/sql` + `github.com/lib/pq` or GORM |
| Email | `github.com/sendgrid/sendgrid-go` |
| Distributed lock | `github.com/go-redis/redis/v9` with SETNX |
| Queue | `github.com/hibiken/asynq` (Redis-based) |

---

*Generated by Algo Function Agent v1.1*
