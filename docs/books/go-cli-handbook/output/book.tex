\documentclass[11pt,a4paper]{book}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{tocloft}
\usepackage{booktabs}

% Page geometry
\geometry{
    left=2.5cm,
    right=2.5cm,
    top=3cm,
    bottom=3cm
}

% Colors
\definecolor{codebackground}{RGB}{248,248,248}
\definecolor{codekeyword}{RGB}{0,0,180}
\definecolor{codecomment}{RGB}{0,128,0}
\definecolor{codestring}{RGB}{163,21,21}
\definecolor{goblue}{RGB}{0,125,156}

% Code listings
\lstdefinelanguage{Go}{
    keywords={break, case, chan, const, continue, default, defer, else, fallthrough, for, func, go, goto, if, import, interface, map, package, range, return, select, struct, switch, type, var},
    keywordstyle=\color{codekeyword}\bfseries,
    ndkeywords={string, int, bool, error, nil, true, false},
    ndkeywordstyle=\color{goblue}\bfseries,
    identifierstyle=\color{black},
    sensitive=true,
    comment=[l]{//},
    morecomment=[s]{/*}{*/},
    commentstyle=\color{codecomment}\itshape,
    stringstyle=\color{codestring},
    morestring=[b]",
    morestring=[b]`
}

\lstset{
    language=Go,
    backgroundcolor=\color{codebackground},
    basicstyle=\ttfamily\small,
    breaklines=true,
    frame=single,
    rulecolor=\color{gray!30},
    numbers=left,
    numberstyle=\tiny\color{gray},
    tabsize=4,
    showstringspaces=false
}

% Bash listings
\lstdefinestyle{bash}{
    language=bash,
    backgroundcolor=\color{codebackground},
    basicstyle=\ttfamily\small,
    breaklines=true,
    frame=single,
    rulecolor=\color{gray!30},
    numbers=none,
    showstringspaces=false
}

% Headers and footers
\pagestyle{fancy}
\fancyhf{}
\fancyhead[LE,RO]{\thepage}
\fancyhead[LO]{\nouppercase{\rightmark}}
\fancyhead[RE]{\nouppercase{\leftmark}}
\renewcommand{\headrulewidth}{0.4pt}

% Hyperlinks
\hypersetup{
    colorlinks=true,
    linkcolor=goblue,
    urlcolor=goblue,
    citecolor=goblue
}

% Title formatting
\titleformat{\chapter}[display]
    {\normalfont\huge\bfseries}
    {\chaptertitlename\ \thechapter}{20pt}{\Huge}

% Document info
\title{\textbf{Building CLI Applications with Go}\\[0.5em]
\large A Practical Guide to Command-Line Tool Development}
\author{Book Writer Team}
\date{January 2, 2026}

\begin{document}

% Title page
\frontmatter
\maketitle

% Copyright
\thispagestyle{empty}
\vspace*{\fill}
\begin{center}
\textbf{Building CLI Applications with Go}\\[1em]
Version 1.2.0\\[2em]
Copyright \textcopyright\ 2026 Book Writer Team\\[1em]
All rights reserved.\\[2em]
Generated by MicroAI Book Writer Team
\end{center}
\vspace*{\fill}
\newpage

% Table of Contents
\tableofcontents

% Main content
\mainmatter

%% ========================================
%% CHAPTER 1: Introduction to CLI Development
%% ========================================

\chapter{Introduction to CLI Development}

\begin{quote}
\textit{``The command line is a powerful tool. Master it, and you'll find yourself more productive than you ever thought possible.''}\\
--- Anonymous Developer
\end{quote}

\section{Introduction}

Every developer has a collection of scripts and small programs that make their daily work easier. Maybe it's a tool to format log files, a script to deploy code, or a utility to manage configurations. At some point, these scripts grow complex enough that they need proper argument parsing, help messages, and error handling. That's when you need a real command-line interface (CLI) application.

In this chapter, we'll explore why Go has become the go-to language for building CLI tools, understand the anatomy of a well-designed command-line application, and create your first ``Hello, CLI'' program.

\subsection{Learning Objectives}

By the end of this chapter, you will be able to:
\begin{itemize}
    \item Understand why Go is an excellent choice for CLI development
    \item Identify the components that make up a CLI application
    \item Use Go's standard library for basic CLI functionality
    \item Apply best practices for exit codes and output streams
\end{itemize}

\section{Why Go for CLI Applications?}

Go has become the preferred language for CLI tools at companies like Google, Docker, and HashiCorp. Here's why.

\subsection{Single Binary Distribution}

Go compiles to a single static binary with no external dependencies:

\begin{lstlisting}[style=bash]
# Build your application
go build -o myapp

# Ship it anywhere - no runtime needed
scp myapp server:/usr/local/bin/
\end{lstlisting}

\subsection{Fast Startup Time}

CLI tools need to start instantly. Go programs typically start in milliseconds:

\begin{lstlisting}[style=bash]
time ./myapp --help
# real    0m0.003s  <- Go is fast!
\end{lstlisting}

\subsection{Cross-Platform Compilation}

Go's cross-compilation is remarkably simple:

\begin{lstlisting}[style=bash]
# Build for Linux from macOS
GOOS=linux GOARCH=amd64 go build -o myapp-linux

# Build for Windows
GOOS=windows GOARCH=amd64 go build -o myapp.exe

# Build for ARM (Raspberry Pi, Apple Silicon)
GOOS=linux GOARCH=arm64 go build -o myapp-arm
\end{lstlisting}

\subsection{Strong Standard Library}

Go's standard library provides everything you need:

\begin{table}[h]
\centering
\begin{tabular}{ll}
\toprule
\textbf{Package} & \textbf{Purpose} \\
\midrule
\texttt{flag} & Command-line flag parsing \\
\texttt{os} & Environment variables, exit codes \\
\texttt{os/exec} & Running external commands \\
\texttt{io} & Input/output interfaces \\
\texttt{fmt} & Formatted I/O \\
\texttt{bufio} & Buffered I/O \\
\bottomrule
\end{tabular}
\caption{Essential Go packages for CLI development}
\end{table}

\section{Anatomy of a CLI Application}

\subsection{The Command Structure}

\begin{verbatim}
myapp <command> [subcommand] [flags] [arguments]
\end{verbatim}

\begin{itemize}
    \item \textbf{Program name} (\texttt{myapp}): The executable name
    \item \textbf{Command} (\texttt{serve}, \texttt{config}): The action to perform
    \item \textbf{Subcommand} (\texttt{config get}): Nested actions
    \item \textbf{Flags} (\texttt{--port 8080}): Modifiers
    \item \textbf{Arguments} (\texttt{file.txt}): Positional inputs
\end{itemize}

\subsection{Exit Codes}

\begin{table}[h]
\centering
\begin{tabular}{ll}
\toprule
\textbf{Code} & \textbf{Meaning} \\
\midrule
0 & Success \\
1 & General error \\
2 & Misuse of command \\
126 & Command cannot execute \\
127 & Command not found \\
\bottomrule
\end{tabular}
\caption{Standard Unix exit codes}
\end{table}

\section{Your First CLI Application}

\subsection{Basic Implementation}

\begin{lstlisting}
package main

import (
    "flag"
    "fmt"
    "os"
)

var version = "dev"

func main() {
    name := flag.String("name", "World", "Name to greet")
    excited := flag.Bool("excited", false, "Add excitement")
    showVersion := flag.Bool("version", false, "Show version")

    flag.Usage = func() {
        fmt.Fprintf(os.Stderr, "Usage: %s [options]\n\n", os.Args[0])
        fmt.Fprintf(os.Stderr, "A friendly greeting application.\n\n")
        fmt.Fprintf(os.Stderr, "Options:\n")
        flag.PrintDefaults()
    }

    flag.Parse()

    if *showVersion {
        fmt.Printf("hello-cli version %s\n", version)
        os.Exit(0)
    }

    if *name == "" {
        fmt.Fprintln(os.Stderr, "Error: name cannot be empty")
        os.Exit(2)
    }

    greeting := fmt.Sprintf("Hello, %s", *name)
    if *excited {
        greeting += "!"
    } else {
        greeting += "."
    }

    fmt.Println(greeting)
    os.Exit(0)
}
\end{lstlisting}

\section{Summary}

In this chapter, you learned:

\begin{itemize}
    \item \textbf{Why Go excels at CLI development}: Single binaries, fast startup, easy cross-compilation
    \item \textbf{CLI application anatomy}: Commands, flags, arguments, streams, exit codes
    \item \textbf{Practical implementation}: Using the \texttt{flag} package and Unix conventions
\end{itemize}

%% ========================================
%% CHAPTER 2: Parsing Arguments and Flags
%% ========================================

\chapter{Parsing Arguments and Flags}

\begin{quote}
\textit{``A program should be light and agile, its subroutines connected like a string of pearls.''}\\
--- The Tao of Programming
\end{quote}

\section{Introduction}

In Chapter 1, we built a simple CLI application using the \texttt{flag} package. But real-world CLI tools need more sophisticated argument handling: positional arguments, required flags, custom types, environment variable fallbacks, and even manual subcommand routing.

This chapter takes you deeper into Go's argument parsing capabilities.

\subsection{Learning Objectives}

By the end of this chapter, you will be able to:
\begin{itemize}
    \item Master advanced techniques with the \texttt{flag} package
    \item Handle positional arguments alongside flags
    \item Create custom flag types for validation and parsing
    \item Implement environment variable fallbacks
    \item Build manual subcommand routing
\end{itemize}

\section{The flag Package Deep Dive}

\subsection{Flag Definition Methods}

Go provides two styles for defining flags:

\textbf{Pointer Style:}
\begin{lstlisting}
name := flag.String("name", "default", "description")
// name is *string, use *name to get value
\end{lstlisting}

\textbf{Variable Style:}
\begin{lstlisting}
var name string
flag.StringVar(&name, "name", "default", "description")
// name is string, use directly
\end{lstlisting}

\subsection{Supported Flag Types}

\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Type} & \textbf{Functions} & \textbf{Example} \\
\midrule
\texttt{bool} & \texttt{Bool}, \texttt{BoolVar} & \texttt{--verbose}, \texttt{-v} \\
\texttt{int} & \texttt{Int}, \texttt{IntVar} & \texttt{--port 8080} \\
\texttt{string} & \texttt{String}, \texttt{StringVar} & \texttt{--name "value"} \\
\texttt{time.Duration} & \texttt{Duration}, \texttt{DurationVar} & \texttt{--timeout 30s} \\
\bottomrule
\end{tabular}
\caption{Built-in flag types in Go}
\end{table}

\section{Custom Flag Types}

Any type implementing \texttt{flag.Value} can be used as a flag:

\begin{lstlisting}
type Value interface {
    String() string
    Set(string) error
}
\end{lstlisting}

\subsection{Example: String Slice Flag}

\begin{lstlisting}
type StringSlice []string

func (s *StringSlice) String() string {
    return strings.Join(*s, ", ")
}

func (s *StringSlice) Set(value string) error {
    *s = append(*s, value)
    return nil
}

func main() {
    var tags StringSlice
    flag.Var(&tags, "tag", "Add a tag (can be repeated)")
    flag.Parse()
    fmt.Printf("Tags: %v\n", tags)
}
\end{lstlisting}

\section{Environment Variable Fallbacks}

Professional CLI tools read configuration from multiple sources:

\begin{verbatim}
Command-line flags (highest priority)
    |
Environment variables
    |
Configuration file
    |
Default values (lowest priority)
\end{verbatim}

\begin{lstlisting}
func envOr(key, fallback string) string {
    if v := os.Getenv(key); v != "" {
        return v
    }
    return fallback
}

func main() {
    host := flag.String("host", envOr("APP_HOST", "localhost"),
        "Server host (env: APP_HOST)")
    flag.Parse()
}
\end{lstlisting}

\section{Manual Subcommand Routing}

Use \texttt{flag.NewFlagSet} for isolated flag sets per command:

\begin{lstlisting}
func main() {
    if len(os.Args) < 2 {
        printUsage()
        os.Exit(2)
    }

    switch os.Args[1] {
    case "serve":
        serveCmd(os.Args[2:])
    case "config":
        configCmd(os.Args[2:])
    default:
        fmt.Fprintf(os.Stderr, "Unknown command: %s\n", os.Args[1])
        os.Exit(2)
    }
}

func serveCmd(args []string) {
    fs := flag.NewFlagSet("serve", flag.ExitOnError)
    port := fs.Int("port", 8080, "Port to listen on")
    fs.Parse(args)
    fmt.Printf("Starting server on port %d\n", *port)
}
\end{lstlisting}

\section{Summary}

In this chapter, you learned:

\begin{itemize}
    \item \textbf{Advanced flag techniques}: Variable binding, all supported types
    \item \textbf{Custom flag types}: Implementing \texttt{flag.Value} for domain-specific validation
    \item \textbf{Environment integration}: Building proper precedence chains
    \item \textbf{Manual subcommands}: Using \texttt{flag.NewFlagSet} for isolation
\end{itemize}

%% ========================================
%% CHAPTER 3: Using Cobra for Professional CLIs
%% ========================================

\chapter{Using Cobra for Professional CLIs}

\begin{quote}
\textit{``Complexity is the enemy of execution.''}\\
--- Tony Robbins
\end{quote}

\section{Introduction}

In Chapters 1 and 2, we built CLI applications using Go's standard library. While the \texttt{flag} package is powerful, building complex applications with subcommands, shell completions, and auto-generated documentation requires significant boilerplate code.

Enter Cobra---the CLI framework that powers some of the most popular command-line tools in the world: Kubernetes (\texttt{kubectl}), Docker, GitHub CLI (\texttt{gh}), Hugo, and hundreds more.

\subsection{Learning Objectives}

By the end of this chapter, you will be able to:
\begin{itemize}
    \item Understand Cobra's architecture and design philosophy
    \item Structure applications with commands and subcommands
    \item Work with persistent and local flags
    \item Generate shell completions automatically
    \item Integrate with Viper for configuration management
\end{itemize}

\section{Why Cobra?}

\subsection{Industry Adoption}

\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Tool} & \textbf{Company} & \textbf{Stars} \\
\midrule
kubectl & Google/CNCF & 100k+ \\
docker & Docker & 68k+ \\
gh & GitHub & 35k+ \\
hugo & Hugo Authors & 72k+ \\
terraform & HashiCorp & 40k+ \\
\bottomrule
\end{tabular}
\caption{Major tools built with Cobra}
\end{table}

\textbf{Cobra itself has 35,000+ stars and is used in 184,000+ projects.}

\subsection{What Cobra Provides}

\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Feature} & \textbf{Standard Library} & \textbf{Cobra} \\
\midrule
Basic flags & Yes & Yes \\
Subcommands & Manual & Built-in \\
Nested subcommands & Complex & Easy \\
Shell completions & No & Automatic \\
Man page generation & No & Automatic \\
Viper integration & No & Seamless \\
\bottomrule
\end{tabular}
\caption{Standard library vs Cobra comparison}
\end{table}

\section{Getting Started with Cobra}

\subsection{Installation}

\begin{lstlisting}[style=bash]
# Add Cobra to your project
go get -u github.com/spf13/cobra@latest

# Optional: Install the Cobra CLI generator
go install github.com/spf13/cobra-cli@latest
\end{lstlisting}

\subsection{Project Structure}

A typical Cobra application follows this structure:

\begin{verbatim}
myapp/
+-- cmd/
|   +-- root.go        # Root command (entry point)
|   +-- serve.go       # serve subcommand
|   +-- config.go      # config subcommand
|   +-- version.go     # version subcommand
+-- internal/
|   +-- ...            # Business logic
+-- main.go            # Minimal main function
+-- go.mod
\end{verbatim}

\section{Your First Cobra Application}

\subsection{Root Command}

\begin{lstlisting}
package cmd

import (
    "fmt"
    "os"

    "github.com/spf13/cobra"
)

var verbose bool

var rootCmd = &cobra.Command{
    Use:   "taskctl",
    Short: "A task management CLI tool",
    Long: `taskctl is a command-line task manager that helps you
organize and track your daily tasks efficiently.`,
    Run: func(cmd *cobra.Command, args []string) {
        cmd.Help()
    },
}

func Execute() {
    if err := rootCmd.Execute(); err != nil {
        fmt.Fprintln(os.Stderr, err)
        os.Exit(1)
    }
}

func init() {
    rootCmd.PersistentFlags().BoolVarP(&verbose, "verbose", "v", false,
        "Enable verbose output")
}
\end{lstlisting}

\subsection{Adding Subcommands}

\begin{lstlisting}
var addCmd = &cobra.Command{
    Use:   "add [task description]",
    Short: "Add a new task",
    Args:  cobra.MinimumNArgs(1),
    RunE: func(cmd *cobra.Command, args []string) error {
        description := strings.Join(args, " ")
        fmt.Printf("Added task: %s\n", description)
        return nil
    },
}

func init() {
    rootCmd.AddCommand(addCmd)
}
\end{lstlisting}

\section{Flags Deep Dive}

\subsection{Persistent vs Local Flags}

\begin{lstlisting}
// Persistent flags: inherited by all subcommands
rootCmd.PersistentFlags().StringVar(&cfgFile, "config", "", "Config file")

// Local flags: only for this command
serveCmd.Flags().IntVarP(&port, "port", "p", 8080, "Port to listen on")
\end{lstlisting}

\subsection{Flag Groups}

\begin{lstlisting}
// Mutually exclusive flags
cmd.Flags().String("json", "", "Output as JSON")
cmd.Flags().String("yaml", "", "Output as YAML")
cmd.MarkFlagsMutuallyExclusive("json", "yaml")

// Required together
cmd.Flags().String("username", "", "Username")
cmd.Flags().String("password", "", "Password")
cmd.MarkFlagsRequiredTogether("username", "password")
\end{lstlisting}

\section{Command Hierarchy}

Build deep command trees like \texttt{kubectl get pods}:

\begin{lstlisting}
// cmd/config.go
var configCmd = &cobra.Command{
    Use:   "config",
    Short: "Manage configuration",
}

func init() {
    rootCmd.AddCommand(configCmd)
}

// cmd/config_get.go
var configGetCmd = &cobra.Command{
    Use:   "get [key]",
    Short: "Get a configuration value",
    Args:  cobra.ExactArgs(1),
    Run: func(cmd *cobra.Command, args []string) {
        fmt.Printf("Config value for %s: ...\n", args[0])
    },
}

func init() {
    configCmd.AddCommand(configGetCmd)
}
\end{lstlisting}

\section{Pre/Post Run Hooks}

Hooks execute in order, allowing setup and cleanup:

\begin{lstlisting}
var rootCmd = &cobra.Command{
    Use: "myapp",
    PersistentPreRunE: func(cmd *cobra.Command, args []string) error {
        // Runs before ANY command (including subcommands)
        return loadConfig()
    },
    PersistentPostRun: func(cmd *cobra.Command, args []string) {
        // Runs after ANY command
        fmt.Println("Cleanup complete")
    },
}
\end{lstlisting}

\textbf{Execution order:}
\begin{enumerate}
    \item \texttt{PersistentPreRun} (root)
    \item \texttt{PreRun} (command)
    \item \texttt{Run} (command)
    \item \texttt{PostRun} (command)
    \item \texttt{PersistentPostRun} (root)
\end{enumerate}

\section{Shell Completions}

Cobra automatically generates shell completions:

\begin{lstlisting}[style=bash]
# Generate bash completions
./myapp completion bash > /etc/bash_completion.d/myapp

# Generate zsh completions
./myapp completion zsh > "${fpath[1]}/_myapp"

# Generate fish completions
./myapp completion fish > ~/.config/fish/completions/myapp.fish
\end{lstlisting}

\subsection{Custom Completions}

\begin{lstlisting}
var statusCmd = &cobra.Command{
    Use:       "status [resource]",
    ValidArgs: []string{"pods", "services", "deployments"},
}

func init() {
    statusCmd.Flags().String("namespace", "", "Kubernetes namespace")
    statusCmd.RegisterFlagCompletionFunc("namespace",
        func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
            return getNamespaces(), cobra.ShellCompDirectiveNoFileComp
        })
}
\end{lstlisting}

\section{Integrating with Viper}

Viper provides configuration management that integrates seamlessly with Cobra:

\begin{lstlisting}
func init() {
    rootCmd.PersistentFlags().StringVar(&cfgFile, "config", "",
        "config file (default: $HOME/.myapp.yaml)")

    // Bind flags to viper
    rootCmd.PersistentFlags().String("log-level", "info", "Log level")
    viper.BindPFlag("log-level", rootCmd.PersistentFlags().Lookup("log-level"))

    // Environment variable binding
    viper.SetEnvPrefix("MYAPP")
    viper.AutomaticEnv()
}

func initConfig() error {
    if cfgFile != "" {
        viper.SetConfigFile(cfgFile)
    } else {
        home, _ := os.UserHomeDir()
        viper.AddConfigPath(home)
        viper.SetConfigName(".myapp")
    }
    return viper.ReadInConfig()
}
\end{lstlisting}

\subsection{Configuration Precedence}

With Viper, configuration follows this precedence (highest to lowest):

\begin{enumerate}
    \item Explicit \texttt{Set} calls
    \item Command-line flags
    \item Environment variables
    \item Config file
    \item Default values
\end{enumerate}

\section{Summary}

In this chapter, you learned:

\begin{itemize}
    \item \textbf{Cobra's architecture}: Commands, flags, and the execution lifecycle
    \item \textbf{Project structure}: Organizing code with separate files per command
    \item \textbf{Flags and arguments}: Persistent vs local flags, required flags, flag groups
    \item \textbf{Command hierarchy}: Nested subcommands with \texttt{AddCommand}
    \item \textbf{Shell completions}: Automatic and custom completions
    \item \textbf{Viper integration}: Seamless configuration management
\end{itemize}

\subsection{Key Takeaways}

\begin{enumerate}
    \item Use \texttt{RunE} instead of \texttt{Run} when errors can occur
    \item Persistent flags on root are inherited by all subcommands
    \item Bind flags to Viper for unified configuration
    \item Shell completions are free---just generate them
    \item Pre/PostRun hooks are perfect for setup and cleanup
\end{enumerate}

%% ========================================
%% BACKMATTER
%% ========================================

\backmatter

\chapter*{About This Book}
\addcontentsline{toc}{chapter}{About This Book}

This book was generated by the MicroAI Book Writer Team, a multi-agent system consisting of:

\begin{itemize}
    \item \textbf{Planner Agent}: Book structure and outline design
    \item \textbf{Researcher Agent}: Technical research and fact-checking
    \item \textbf{Writer Agent}: Content creation
    \item \textbf{Editor Agent}: Grammar, style, and consistency
    \item \textbf{Reviewer Agent}: Technical accuracy verification
    \item \textbf{Publisher Agent}: Multi-format output generation
\end{itemize}

\section*{Version History}

\begin{tabular}{lll}
\toprule
\textbf{Version} & \textbf{Date} & \textbf{Changes} \\
\midrule
1.0.0 & January 2, 2026 & Initial release with Chapter 1 \\
1.1.0 & January 2, 2026 & Added Chapter 2 \\
1.2.0 & January 2, 2026 & Added Chapter 3 \\
\bottomrule
\end{tabular}

\section*{Upcoming Chapters}

\begin{enumerate}
    \setcounter{enumi}{3}
    \item Working with Files and Streams
    \item Terminal User Interfaces
    \item Configuration Management
    \item Error Handling and Logging
    \item Testing CLI Applications
    \item Concurrency in CLI Tools
    \item Building and Distribution
    \item Real-World Project
\end{enumerate}

\end{document}
